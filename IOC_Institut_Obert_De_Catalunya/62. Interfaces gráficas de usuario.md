# 62\. Interfaces gráficas de usuario. Swing.

# Resumen

- **Qué conceptos avanzados de Java intentan ir más allá de la simple creación de clases y de la implementación de métodos?**
    - La generación de interfaces gráficas de usuario.
    - El tratamiento de grandes cantidades de datos mediante flujos.
- **Qué proporciona Java para la generación de interfaces gráficas de usuario?**
    - Proporciona una biblioteca principal que contiene una jerarquía de clases de medida considerable.
- **En qué 2 grupos se dividen los elementos gráficos en Java?**
    - Controles
    - Contenedores
- **Qué son los Controles?**
    - Son los elementos que aceptan interacciones por parte del usuario, como:
        - botones
        - opciones de menú
        - formularios de texto
- **Qué son los Contenedores?**
    - Son elementos sobre los cuales se ubican los controles u otros contenedores, como por ejemplo la ventana principal.
- **Qué necesitamos para ubicar los controles dentro de un contenedor?**
    - Necesitamos usar un *layout*, una política de ubicación automática de los diferentes controles.
- **Qué permite el hecho de necesitar usar un *layout* para ubicar los controles dentro de un contenedor?**
    - Permite mantener las proporciones de la interfaz independientemente de la resolución de pantalla.
    - Permite que la ventana principal se redimensione.
- **Cuál es uno de los aspectos más importantes cuando generamos una interfaz gráfica?**
    - Garantizar que la interfaz gráfica sea independiente de cómo se presenta el estado de la aplicación.
- **Qué usamos para garantizar que la interfaz gráfica que creamos sea independiente del estado de la aplicación?**
    - El patrón de diseño Modelo-Vista-Controlador (MVC).
- **Qué sucede con el Modelo-Vista-Controlador (MVC)?**
    - Las clases de una aplicación se dividen en 3 grupos según las funciones que tengan.
- **Qué se agrupa dentro del apartado Modelo del MVC?**
    - Se agrupan los resultantes del proceso de diseño, representados con el diagrama estático UML.
- **Qué se agrupa dentro del apartado Vista del MVC?**
    - Se engloban todos los elementos gráficos, tanto los controles como los contenedores.
- **Qué se agrupa dentro del apartado Controlador del MVC?**
    - Contiene todas las clases que traducen las interacciones del usuario con las llamadas a métodos de clases del Modelo.
- **Qué generan los controles en una interfaz gráfica?**
    - Generan eventos frente las interacciones del usuario.
- **Qué genera cada tipo de interacción del usuario?**
    - Genera un evento distinto: del teclado, del ratón, etc.
- **Qué necesitamos para capturar este tipo de eventos?**
    - Necesitamos registrar un tipo especial de clases, la llamadas Listeners, en los controles.
- **Cuantas clases Listeners hay?**
    - Hay una clase Listener para cada tipo de evento.
- **Qué sucede si un control no tiene un Listener registrado para un evento concreto?**
    - El evento se ignora aunque el usuario haga la acción que lo provoca.
- **De qué se encarga el Listener registrado para un evento concreto de un control?**
    - Captura el evento y se encarga de ejecutar un código determinado.
- **Qué clases conforman el apartado Controlador del MVC?**
    - Las clases Listeners.
- **Qué son las "clases basadas en modelo"?**
    - Son el conjunto de contenedores con los que el programador no puede interactuar directamente para modificar su apariencia por pantalla.
- **En qué se basa Java para procesar datos?**
    - En el mecanismo de flujos.
- **Qué son los flujos en Java?**
    - Son bloques de datos que se transmiten secuencialmente desde un origen de datos (*data source*) a un destino de datos (*data sink*).
- **Qué pueden ser tanto el origen de datos como el destino de datos?**
    - Pueden ser cualquier componente que procese o almacene datos: un fichero, un buffer de memoria, una aplicación, etc.
- **En qué dos grupos divide Java los flujos según la unidad básica de datos?**
    - En el grupo de flujos orientados a datos:
        - Operan con el tipo primitivo byte.
    - En el grupo de flujos orientados a carácter:
        - Operan con el tipo char.
- **Qué proporciona Java para que un flujo pueda operar en alto nivel (con otros tipos de datos primitivos diferentes a byte o char, con cadenas de texto, o hasta con objetos)?**
    - Proporciona la capacidad de poder aplicar clases modificadoras sobre un flujo.
- **Qué nombre tiene el mecanismo que permite operar directamente con objetos sobre flujos?**
    - Serialización.

* * *

# Mapa conceptual

![62_00_Mapa_Conceptual.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/62_00_Mapa_Conceptual.png)

* * *

# 1\. Interfaces gráficas de usuario

- **Qué es una GUI?**
    - Es un tipo de interfaz en que los mecanismos que utiliza el usuario para dar órdenes al programa o visualizar cualquier tipo de información se basa en la manipulación de iconos en vez de en la entrada de órdenes textuales.
- **En qué año se realizaron las primeras GUI?**
    - En los años 60.
- **Qué empresa fue la que creó las primeras GUI?**
    - La empresa Xerox.
- **Qué consideró Alan Kay a finales de los años 60 y principios de los 70 respecto a la programación orientada a objetos y las GUI?**
    - Que la metodología de orientación a objetos era especialmente indicada para el diseño de entornos gráficos.
- **En qué consiste una GUI?**
    - Es un ejemplo evidente de elementos claramente identificables, con unas propiedades y un comportamiento, que interactúan para llevar a cabo una faena concreta.
- **De quién fueron las ideas que usaron los investigadores de la empresa Xerox para crear un ordenador con entorno totalmente gráfico?**
    - De Alan Kay.
- **Cómo se llama el primer ordenador que se creó con entorno totalmente gráfico, creado por la empresa Xerox?**
    - El Dynabook.
- **Cuál fue uno de los primeros lenguajes orientados a objetos que se crearon usando los postulados de Alan Kay?**
    - El lenguaje SmallTalk.
- **Qué lenguaje surge en los años 90 que también usa los postulados de Alan Kay?**
    - El lenguaje Java.
- **Para qué estaba especialmente orientado Java en sus inicios?**
    - Para poder incluir en páginas web elementos gráficos dinámicos, en forma de pequeños programas que se ejecutaban en el navegador: los *applets*.
- **Quién fue el desarrollador que hizo la primera versión de la biblioteca gráfica?**
    - Netscape Communications.
- **Qué necesitamos entender para generar entornos gráficos mediante el Java?**
    - Necesitamos entender:
        - cuales son las clases relacionadas con los elementos gráficos.
        - cómo se vinculan las clases relacionadas con los elementos gráficos.

* * *

## 1.1. El paquete Java Swing

- **A qué package pertenecen las clases vinculadas al entorno gráfico de Java?**
    - Al package javax.swing.
- **Cómo se conoce familiarmente al package javax.swing?**
    - A la biblioteca Java Swing o simplemente Swing.
- **Cuál es la biblioteca original de Java creada para crear interfaces gráficas?**
    - AWT (Abstract Windows Toolkit),
- **En qué año surgió la biblioteca AWT?**
    - En el 1995.
- **Por qué se creó Swing?**
    - Porque si querías que la interfaz gráfica creada con AWT se viese igual en todos las arquitecturas donde ejecutaras la aplicación, solo podías lograrlo creando interfaces muy feas.
    - AWT tiene código nativo y por tanto pesa mucho.
    - Para solucionar los problemas que daba AWT.
- **Qué aspectos reutiliza la biblioteca Swing que son de AWT?**
    - La estrategia que necesitamos usar para vincular la lógica interna del programa a la interfaz gráfica.
    - Cómo se pueden organizar los elementos gráficos dentro de una ventana.

* * *

### 1.1.1. Jerarquía de clases Swing

- **Qué representa cada una de las clases que forman parte de la jerarquía de clases de la biblioteca Swing?**
    - Cada clase representa un elemento típico de un entorno gráfico: ventanas, botones, formularios, menús, etc.
- **Qué necesitamos hacer si queremos incluir alguno de estos elementos en la interfaz gráfica de la aplicación?**
    - Necesitamos instanciar la clase pertinente.
- **Esquema de una pequeña parte de la jerarquía de clases Swing:**

![62_01_Jerarquia_Clases_Swing.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/62_01_Jerarquia_Clases_Swing.png)

- **Qué es un componente?**
    
    - Cualquier elemento gráfico que se encuentre dentro de la interfaz gráfica, ya que todos son un objeto java.awt.Component.
- **Cómo podemos distinguir las clases incluidas en la biblioteca de Swing?**
    
    - Se distinguen porque empiezan todas con la letra J.
- **De qué clases de AWT hereda Swing?**
    
    - java.awt.Component y java.awt.Container.
- **Qué especifican la clase Component y la Container de AWT?**
    
    - Especifican todos los aspectos genéricos del comportamiento de los elementos de un entorno gráfico.
- **Qué permite al motor gráfico de Java garantizar que cada componente siempre tiene implementado todo el conjunto de métodos necesarios para visualizarlos correctamente y llamarlos polimórficamente?**
    
    - Que la clase java.awt.Component y la java.awt.Container definen métodos que las subclases pueden suscribir de acuerdo a sus particularidades.
- **Qué especifica la clase abstracta java.awt.Component?**
    
    - Define todas las características referentes al aspecto de un elemento gráfico, como:
        - la medida
        - la fuente del texto que contiene
        - si está habilitado
        - la ubicación en la pantalla
        - el conjunto de interacciones que el elemento puede recibir
        - etc.
    - Define todo el conjunto de interacciones que el elemento puede recibir:
        - ser pulsado
        - ser seleccionado
        - poner el puntero del ratón encima
        - etc.
- **Qué especifica la clase java.awt.Container?**
    
    - Especifica todo el comportamiento relativo a la capacidad de un elemento gráfico de contener a otros.
- **JButton:**
    
    - Corresponde al botón típico que se puede apretar para dar órdenes a la aplicación.
- **JToggleButton:**
    
    - Se trata de un botón especial que se ve como en volumen, que alterna entre un estado pulsado o no. Cada vez que se pulsa cambia el estado.
- **JCheckBox:**
    
    - Representa un selector de opción con un texto asociado.
    - La forma del selector es tipo cheked / uncheked (marcado/no marcado).
    - Útil para hacer apartados de configuración o formularios de tipo test.
- **JRadioButton:**
    
    - Representa un selector de opción con un texto asociado.
    - La forma del selector es redonda.
    - Útil para hacer apartados de configuración o formularios de tipo test.
- **JLabel:**
    
    - Corresponde a una etiqueta en la que se puede mostrar texto o una imagen.
    - No se puede escribir.
- **JTextField:**
    
    - Corresponde a un campo de texto, en que el usuario puede escribir.
    - Solo puede escribir una única línea.
    - No permite variar el estilo dentro del texto (medida o tipo de fuente).
- **JTextArea:**
    
    - Similar al anterior.
    - Especifica un campo de texto en el que se puede escribir libremente, sin limitación de una única línea.
- **JTextPane:**
    
    - Componente de funcionalidad prácticamente idéntica al área de texto, pero con la capacidad añadida de poder editar texto con estilo diferente (cursiva, negrita, etc.)
- **JList:**
    
    - Listado de elementos o ítems, normalmente cadenas de texto, entre las cuales se puede seleccionar un conjunto.
- **JFrame:**
    
    - Ventana principal de la interfaz gráfica en una aplicación de escritorio.
- **JApplet:**
    
    - Ventana principal de la interfaz gráfica en una aplicación incrustada en una página web, un applet.
- **JDialog:**
    
    - Cuadro de alerta o de diálogo con el usuario.
- **JPanel:**
    
    - Representa un área específica de la ventana, con unas propiedades concretas diferenciadas:
        - color de fondo
        - borde
        - etc.
- **JScrollPane:**
    
    - Idéntico al anterior, pero si en algún momento la medida de la ventana es demasiado pequeña para visualizar todo el contenido de esta área, aparece una barra de desplazamiento (*scroll*).
- **JTabbedPane:**
    
    - Conjunto de paneles accesible mediante etiquetas (*tabs*) con una cadena de texto, de manera parecida a fichas de biblioteca.
    - Cada panel está asociado a una etiqueta, de manera que cuando pulsas, solo se visualiza este panel.

* * *

### 1.1.2. Agregación de componentes

- **De qué 2 clases heredan todas las clases de Swing?**
    - java.awt.Component
    - java.awt.Container
- **Qué 2 tipos de componentes encontramos dentro de la jerarquía de Swing?**
    - Controles.
    - Contenedores.
- **Qué permiten los Controles?**
    - Son los componentes con los que el usuario interactúa directamente:
        - botones
        - opciones de menú
        - cuadros de texto
        - etc.
- **Ejemplos de Controles:**
    - JButton
    - JToggleButton
    - JCheckBox
    - JRadioButton
    - JLabel
    - JList
    - JTextField
    - JTextArea
    - JTextPlane
- **Qué permiten los Contenedores?**
    - Son aquellos componentes que no tienen una función directa de interacción con el usuario.
    - Sirven exclusivamente para meter y organizar dentro de cualquier componente, tanto de controles como de contenedores.
- **Ejemplos de Contenedores:**
    - JFrame
    - JDialog
    - JApplet
    - JPanel
    - JScrollPane
    - JTabbedPane
- **Qué diferencia hay entre un control y un contenedor?**
    - Un contenedor puede tener dentro de sí controles y contenedores. En cambio un control no puede tener dentro de sí ni controles ni contenedores.
- **Qué forma toma la estructura de una aplicación con Swing?**
    - La forma de un árbol N-áreo. Los objetos en las hojas corresponden a controles y el resto a contenedores.
- **Qué nombre se le da al contenedor que contiene otro componente como hijo?**
    - Contenedor padre.
- **A qué método necesitamos llamar para añadir cualquier componente dentro de un contenedor?**
    - add(Component comp), llamado por el contenedor, pasando como parámetro el componente a añadir.
- **Dónde se encuentra definido el método add(Component comp)?**
    - En la clase java.awt.Container, que heredan todas las clases de la biblioteca Swing.
- **Cómo se denominan los contenedores principales de la aplicación?**
    - contenedores de alto nivel (*top-level containers*)
- **Qué tienen de especial los top-level containers?**
    - El objeto raíz del árbol que conforma el mapa de objetos de la interfaz gráfica siempre es un contenedor de este subtipo.
- **Qué 3 tipos de contenedores top-level define Swing?**
    - JFrame
    - JApplet
    - JDialog
- **Podemos añadir componentes a los contenedores top-level usando el método add(Component comp)?**
    - No.
- **Cómo podemos añadir componentes a los contenedores top-level?**
    - Mediante su panel de contenido (content pane).
- **Cómo podemos obtener el *content pane* del contenedor *top-level*?**
    - Mediante el método getContentPane().
- **Ejemplo de cómo se representaría una interfaz gráfica concreta en forma de mapa de objetos y su clasificación por tipos. Estructura de una calculadora simple:**

![62_03_Representacion_Interfaz_Grafica_Mapa_Objetos.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/62_03_Representacion_Interfaz_Grafica_Mapa_Objetos.png)

- **Qué tenemos que lograr cuando creamos la interfaz gráfica con Swing?**
    - Que todo acabe estando vinculado a un contenedor top-level de la aplicación:
        - Será necesario instanciar las diferentes clases asociadas a cada componente del *content pane*.
        - Será necesario añadir cada control obtenido en los contenedores correspondientes.
- **Qué contenedor *top-level* usaremos?**
    - Una instancia de JFrame.
- **Ejemplo de código necesario para generar un *content pane*:**

```java
    //Contenedor de alto nivel (top-level): ventana principal
    JFrame calculadora = new JFrame("Calculadora");
    //Panel de contenido (content pane)
    Container panel = calculadora.getContentPane();
    ...
    //Display de la calculadora
    JLabel display = new JLabel();              
    display.setHorizontalAlignment(SwingConstants.RIGHT); 
    panel.add(display);
    ...
    //Panel auxiliar en el que poner los buttons     
    JPanel panelBotones = new JPanel();
    JButton boton7 = new JButton("7");
    JButton boton8 = new JButton("8");
    ...
    JButton botonC = new JButton("C");
    //Añadir buttons al panel auxiliar
    panelBotones.add(boton7);
    panelBotones.add(boton8);                 
    ...
    panelBotons.add(botonC);
    //Añadir panel auxiliar de botones a la interfaz
    panel.add(panelBotones);
    calculadora.setVisible();
```

* * *

### 1.1.3. La barra de menús

- **Qué se suele usar en las aplicaciones de escritorio para dar acceso a muchas opciones sin cargar demasiado la pantalla?**
    - Los menús en la franja superior de la ventana principal.
- **Cuáles son los 5 componentes principales vinculados a los menús dentro de la biblioteca Swing?**
    - JMenuBar
    - JMenu
    - JMenuItem
    - JCheckBoxMenuItem
    - JRadioButtonMenuItem
- **JMenuBar:**
    - Contenedor que representa la barra de menús.
    - Solo puede haber uno por ventana (JFrame).
- **JMenu:**
    - Contenedor que representa un menú individual entre los distintos que se pueden incluir dentro de la barra de menús.
    - El usuario visualiza el nombre del menú.
    - Se despliega en pulsar con el ratón encima.
    - Se pueden incluir menús dentro de otros menús, que se despliegan consecutivamente.
- **JMenuItem:**
    - Control asociado a una opción individual de menú que el usuario selecciona.
- **JCheckBoxMenuItem**:
    - Control que combina: JMenuItem + JCheckBox.
- **JRadioButtonMenuItem:**
    - Control que combina: JMenuItem + JRadioButtonMenu.
- **Ejemplo con todos los componentes posibles de una barra de menús.**

![62_2_Todos_Componentes_Posibles_Barra_Menu.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/62_02_Todos_Componentes_Posibles_Barra_Menu.png)

- **Qué método usan los menús para añadir componentes a los contenedores?**
    - add(Component comp)
- **En qué orden se visualizan los componentes del menú?**
    - En el orden en que se han añadido.
- **Cómo asignamos la barra de menús a la ventana principal?**
    - Llamando al método:
        - public void setJMenuBar(JMenuBar menubar)
- **Ejemplo de código que generaría una barra de menús similar a la de la última imagen mostrada:**

```Java
    JFrame navegador = new JFrame();
    JMenuBar barraMenu = new JMenuBar();            
    JMenu viewMenu = new JMenu("View");
    JMenu toolbarSubmenu = new JMenu("Toolbars");            
    ...
    viewMenu.add(toolbarSubmenu);
    JCkeckBoxMenuItem statusbarItem = 
    new JCkeckBoxMenuItem("Status Bar"); 
    statusBar.setSelected();                 
    viewMenu.add(statusbarItem);
    ...                             
    viewMenu.addSeparator();
    JMenuItem stopItem = 
    new JMenuItem("Stop", new ImageIcon("Stop.gif"));       
    stopItem.setMnemonic(KeyEvent.VK_ESCAPE);
    stopItem.setEnabled(false);
    viewMenu.add(stopItem);                 
    ...
    JMenu pagestyleSubmenu = new JMenu("Page Style");         
    pagestyleSubmenu.add (new 
    JMenuCheckBoxMenuItem("No Style"));             
    JMenuCheckBoxMenuItem basicStyle = new 
    JMenuCheckBoxMenuItem("Basic Page Style");
    basicStyle.setSelected();
    pagestyleSubmenu.add (basicStyle)             
    viewMenu.add(pagestyleSubmenu);
    ...
    barraMenu.add(viewMenu);                       
    ...
    navegador.setJMenubar(barraMenu);
```

* * *

### 1.1.4. Layouts

- **Cuál es uno de los objetivos más importantes de la biblioteca de entorno gráfico del Java?**
    
    - Poder generar aplicaciones con un comportamiento homogéneo independientemente de la plataforma en que se ejecuten.
- **Podemos establecer la ubicación y las medidas exactas para cada componente dentro de la interfaz gráfica de Swing?**
    
    - No.
- **Entonces, cómo podemos hacer que se vea bien lo que hay en la interfaz gráfica de Swing?**
    
    - Especificando una política de ubicación de componentes, de manera que el motor gráfico de Java escoge automáticamente la mejor opción de acuerdo a las dimensiones reales de la ventana principal.
- **Qué sucede cada vez que la ventana de la interfaz gráfica de Swing cambia de dimensiones?**
    
    - Los componentes se reubican y redimensionan dinámicamente.
- **Las políticas de ubicación de componentes las tiene que generar el desarrollador?**
    
    - No, Swing ya define un conjunto predeterminado de políticas de ubicación disponible, entre los cuales solo hay que elegir una política determinada para cada contenedor de la interfaz.
- **Cómo se llama cada una de las políticas de ubicación de componentes que define Swing?**
    
    - *layout*.
- **Qué es un *layout*?**
    
    - Es una política de ubicación y dimensionamiento de componentes, de manera que el motor gráfico del Java escoge automáticamente donde se tiene que visualizar y cuál debe ser su medida.
    - Son todas las clases que implementan la interfaz java.awt.LayoutManager.
- **Qué interfaz implementan las clases *layout*?**
    
    - java.awt.LayoutManager.
- **Cuál es el método que se usa para asignar un *layout* a un contenedor?**
    
    - setLayout(LayoutManager manager).
- **Qué medida tienen por defecto todos los componentes?**
    
    - La mínima necesaria para que quepa todo el contenido.
- **Qué contenedores no usan layouts?**
    
    - Los vinculados a menús, ya que un menú nunca se redimensiona ni sus componentes cambian de ubicación. Siempre tienen el mismo aspecto a lo largo de la aplicación.
- **Cuáles son los 6 *layout* más significativos?**
    
    - FlowLayout
    - BorderLayout
    - GridLayout
    - BoxLayout
    - GridBayLayout
    - GroupLayout

### FlowLayout

- **Qué *layout* hay por defecto en todos los contenedores si no se les asigna ningún otro mediante el método setLayout?**
    - FlowLayout.
- **Por qué se le llama FlowLayout al *layout* FlowLayout?:)**
    - Porque se considera que los elementos "fluyen de manera natural" dentro del contenedor.
- **Qué política define FlowLayout?**
    - Todos los componentes se mantienen en su medida por defecto y se van ubicando por líneas, de izquierda a derecha y de arriba a abajo, centrados horizontalmente.
    - Si en un momento dado un componente no cabe en la línea actual, se ubica en la línea inmediatamente inferior.
- **En qué orden se añaden los componentes al contenedor en FlowLayout?**
    - En el mismo orden en que se ha llamado al método add(Component comp) para añadirlos.
- **Cuál es el constructor de de FlowLayout?**
    - public FlowLayout().
- **Ejemplo de como cambia la ubicación de los componentes en el caso de redimensionar el contenedor en FlowLayout.**

![62_04_Ejemplo_Redimension_FlowLayout.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/62_04_Ejemplo_Redimension_FlowLayout.png)

### **BorderLayout**

- **Qué 5 zonas diferenciadas se definen en un componente al que se le aplica BorderLayout?**
    - norte
    - sur
    - este
    - oeste
    - centro
- **Cuántos componentes se pueden ubicar en cada zona definida por BorderLayout?**
    - Solo se puede ubicar 1 componente, que ocupa totalmente la zona y no cambia de posición.
- **Qué zona ocupan los componentes de las zonas norte y sur (BorderLayout)?**
    - El máximo espacio posible horizontal.
    - El mínimo espacio posible vertical.
- **Qué zona ocupan los componentes de las zonas este y oeste(BorderLayout)?**
    - El mínimo espacio posible horizontal.
    - El máximo espacio posible vertical.
- **Qué zona es la única que cambia si usamos BorderLayout como *layout*?**
    - La zona central.
- **Cuál es el constructor de BorderLayout?**
    - public BorderLayout().
- **Por qué el *layout* BorderLayout() es una excepción respecto al resto de *layouts*?**
    - Porque encima de un contenedor que usa BorderLayout se puede llamar a una sobrecarga del método add(Component comp, Object constraints) en que se pasa un parámetro adicional que indica la zona en que se puede ubicar el componente.
- **Qué método usamos (si usamos BorderLayout()) para decir dónde queremos que se ubique el componente en la ventana?**
    - add(Component comp, Object constraints), donde constraints define donde queremos ubicar el componente.
- **Qué 5 constantes define la clase BorderLayout para indicar cada zona en el parámetro *constraints* del método add(Component comp, Object constraints)?**
    - BorderLayout.NORTH
    - BorderLayout.SOUTH
    - BorderLayout.EAST
    - BorderLayout.WEST
    - BorderLayout.CENTER
- **Ejemplo de redimensión de un contenedor que usa el *layout* BorderLayout:**

![62_05_Ejemplo_Redimension_BorderLayout.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/62_05_Ejemplo_Redimension_BorderLayout.png)

### GridLayout

- **De qué se encarga GridLayout?**
    - Organiza el componente como una matriz con celdas de medida idéntica.
- **Cuántos componentes pueden haber en cada celda de GridLayout?**
    - Solo uno.
- **Qué tamaño ocupa cada componente en la celda de GridLayout?**
    - Ocupa todo el espacio disponible independientemente de cuál sea la medida por defecto.
- **Cómo se ubican los componentes en GridLayout?**
    - De izquierda a derecha, en el mismo orden en que se llama al método add.
- **Cuál es el constructor de GridLayout?**
    - public GridLayout(int rows, int cols).
- **Qué indica el parámetro de entrada rows del método anterior?**
    - Indica la cantidad de filas.
- **Qué indica el parámetro de entrada cols del método anterior?**
    - Indica la cantidad de columnas.
- **Ejemplo de redimensionado de un GridLayout:**

![62_06_Ejemplo_Redimension_GridLayout.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/62_06_Ejemplo_Redimension_GridLayout.png)

### BoxLayout

- **Dónde se acostumbra a aplicar el BoxLayout?**
    - Sobre un contenedor específico, el Box, que ya lleva incorporado este *layout* por defecto en ser instanciado.
- **Se puede cambiar el *layout* de un objeto de tipo Box?**
    - No, siempre es de tipo BoxLayout y ya viene incorporado al Box cuando este es instanciado.
- **Qué medida tienen los componentes en BoxLayout?**
    - La medida por defecto.
- **Dónde se ubican los componentes en BoxLayout?**
    - Se ubican en una sola línea horizontal o vertical, centrada.
- **Se pueden generar instancias de la clase Box mediante un método constructor?**
    - No.
- **Cómo podemos generar instancias de la clase Box?**
    - Utilizando uno de los dos métodos estáticos definidos en la misma clase Box. El método elegido depende de si se quieren alinear los componentes horizontalmente o verticalmente:
        - Box alineaVertical = Box.createVerticalBox();
        - Box alineaHorizontal = Box.createHorizontalBox();
- **Ejemplo de redimensionado de un contenedor Box de alineación vertical:**

![62_07_Ejemplo_Redimension_BoxLayout.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/62_07_Ejemplo_Redimension_BoxLayout.png)

- **Cuáles son los 2 componentes especiales que solo pueden añadir mediante add los contenedores Box (ningún otro *layout* puede usarlos)?**
    - Struts y Glues verticales
    - Struts y Glues horizontales
- **Cómo se instancian los componentes Struts y Glues?**
    - Mediante métodos estáticos definidos en la clase Box:
        - Component Box.createVerticalGlue()
        - Component Box.createVerticalStrut(int height)
        - Component Box.createHorizontalGlue()
        - Component Box.createHorizontalStrut(int width)
- **Qué es el Strut?**
    - Espacio en blanco de una cantidad concreta de píxeles (indicado en los parámetros height o width).
- **Si modificamos las dimensiones del Box, se modifican también los espacios marcados por los Struts?**
    - No, los espacios marcados por los Struts se mantienen invariables.
- **Qué es el Glue?**
    - Hace que dos componentes separados por un Glue siempre se ubiquen lo más separado posible el uno del otro según el espacio que haya.
- **Ejemplo de aplicación de Struts y Glues:**

![62_08_Ejemplo_Struts_Glues.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/62_08_Ejemplo_Struts_Glues.png)

### CardLayout

- **Qué hace el *layout* CardLayout?**
    - Organiza los componentes como un montón de cartas apiladas, donde están todos los componentes pero en cada momento solo se puede visualizar uno de ellos.
- **Qué tamaño ocupa el componente que se visualiza en el *layout* CardLayout?**
    - El máximo espacio posible.
- **Qué orden mantienen los componentes en el *layout* CardLayout?**
    - El orden en que se añaden los componentes al montón de componentes es el mismo en que se añaden los componentes al contenedor mediante el método add.
- **Cómo es el constructor de CardLayout?**
    - public CardLayout().
- **Cómo podemos cambiar los diferentes componentes del montón de componentes en CardLayout?**
    - Usando los métodos de la clase CardLayout que sirven para esta finalidad:
        - public void first(Container parent):
            - Salta al primer componente añadido.
        - public void last(Container parent):
            - Salta al último componente añadido.
        - public void next(Container parent):
            - Salta al componente añadido a continuación del visualizado actualmente.
        - public void previous(Container parent):
            - Salta al componente añadido justo antes del visualizado actualmente.
- **Esquema del funcionamiento del CardLayout: Muestra como se alternan los componentes de un CardLayout:**

![62_09_Esquema_Funcionamiento_CardLayout.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/62_09_Esquema_Funcionamiento_CardLayout.png)

### **GridBagLayout**

- **Qué aporta GridBagLayout?**
    - Divide el contenedor en una matriz de celdas.
- **Cuál es la particularidad del *layout* GridBagLayout?**
    - Las diferentes filas y columnas pueden ser de medida desigual.
    - Los componentes incluidos en las celdas pueden ocupar diversas celdas contiguas, tanto en diferentes filas como columnas.
- **Qué espacio ocupan los componentes asignados a las celdas en GridBagLayout?**
    - Siempre ocupan todo el espacio posible de las celdas asignadas.
- **Cuál es el constructor de GridBagLayout?**
    - public GridBagLayout().
- **Con qué clase auxiliar se definen todas las propiedades especiales de las celdas en GridBagLayout?**
    - Con la clase auxiliar GridBagConstraints.
- **Cómo es el método add que usa el layout GridBagLayout para añadir componentes al contenedor?**
    - add(Component comp, GridBagConstraints constraints).
- **8 propiedades que tiene la clase GridBagConstraints para definir cómo se ubica el elemento añadido dentro del conjunto de celdas?**
    - gridx
    - gridy
    - gridwidth
    - gridheight
    - ipadx
    - ipady
    - insets
    - anchor
- **gridx, gridy:**
    - Especifica la fila y la columna en el extremo superior derecho del componente.
    - La primera fila y columna del conjunto de celdas son las posiciones cero.
    - Si no se especifica, el elemento se ubicará justo después de el añadido justo antes.
- **gridwidth, gridheight:**
    - Indica el número de celdas horizontales o verticales que ocupa el componente.
    - Por defecto es 1.
- **ipadx, ipady:**
    - Especifica un espacio alrededor del componente, internamente, en píxeles.
    - El componente nunca será más pequeño que este valor.
    - Por defecto es 0.
- **insets:**
    - Especifica un espacio alrededor del componente, externamente, en píxeles.
    - Se crea un espacio de separación entre el componente y los componentes que lo rodean.
    - Por defecto es 0.
- **anchor:**
    - Usado cuando el componente es más pequeño que la celda.
    - Indica en qué extremo de la celda se tiene que ajustar el componente.
- **Qué constante tenemos que usar si queremos ocupar toda la cantidad de filas y columnas que restan vacías?**
    - constantGridBagConstraints.REMAINDER.
- **Qué constantes podemos usar para indicar el anchor (en qué extremos de la celda se tiene que ajustar el componente?**
    - CENTER (por defecto)
    - PAGE_START
    - PAGE_END
    - LINE_START
    - LINE_END
    - FIRST\_LINE\_START
    - FIRST\_LINE\_END
    - LAST\_LINE\_END
    - LAST\_LINE\_START
- **Ejemplo de redimensionado de GridBagLayout. Las líneas de separación entre celdas en realidad no se ven. El componente 5 está añadido con un anchor de LAST\_LINE\_END:**

![62_10_Ejemplo_Redimension_GridBagLayout.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/62_10_Ejemplo_Redimension_GridBagLayout.png)

### GroupLayout

- **Para qué está muy orientado el layout GroupLayout?**
    - Para el desarrollo automático de interfaces gráficas mediante herramientas auxiliares.
- **Cuál es la filosofía del GroupLayout?**
    - Desplegar los elementos a lo largo de los dos ejes de coordenadas (vertical y orizontal).
- **Cómo se agrupan los elementos a lo largo de los ejes de coordenadas en GroupLayout?**
    - Se agrupan mediante grupos jerárquicos.
    - Puede que en un grupo haya componentes, otros grupos o espacios en blanco.
- **Qué permite hacer una organización jerárquica?**
    - Añadir grupos.
- **Qué son los espacios en blanco?**
    - Espacios entre elementos.
- **Por qué clase se representan los grupos?**
    - GroupLayout.Group.
- **Qué 3 métodos podemos usar de la clase GroupLayout.Group para añadir elementos al grupo?**
    - addComponent(Component comp)
    - addGroup(GroupLayout.Group group)
    - addGap(int size)
- **Qué 2 tipos de grupos encontramos?**
    - Grupos secuenciales.
    - Grupos paralelos.
- **Qué son los grupos secuenciales?**
    - Los elementos se ubican uno tras otro a lo largo del eje de coordenadas correspondiente.
- **Qué son los grupos paralelos?**
    - Los elementos se ubican en paralelo.
- **Qué clase concreta tenemos para el subtipo grupo secuencial?**
    - SequentialGroup.
- **Qué clase concreta tenemos para el subtipo grupo paralelo?**
    - ParallelGroup.
- **Cómo podemos crear un grupo secuencial?**
    - Llamando al método GroupLayout.Group createSequentialGroup().
- **Cómo podemos crear un grupo paralelo?**
    - Llamando al método GroupLayout.Group createParallelGroup().
- **Cuál es el punto clave si queremos usar el layout GroupLayout?**
    - Tiene que haber un único grupo asociado al eje vertical y otro al eje horizontal.
    - Todos los componentes tienen que pertenecer a los dos grupos, uno del eje vertical y otro del eje horizontal.
- **A partir de qué podemos calcular la ubicación de un componente en GroupLayout?**
    - A partir del grupo donde está asociado el componente.
- **Ejemplo para calcular la ubicación de un componente en GroupLayout:**

```Java
    GroupLayout layout = new groupLapout(panel)
    GroupLayout.SequentialLayout hg = 
    layout.createSequentialGroup();
    GroupLayout.ParallelLayout vg = layout.createParallelGroup();
    JLabel l1 = new JLabel("1");
    JLabel l2 = new JLabel("2");
    JLabel l3 = new JLabel("3");
    hg.addComponent(l1);
    hg.addComponent(l2);
    hg.addComponent(l3);
    vg.addComponent(l1);
    vg.addComponent(l2);
    vg.addComponent(l3);
    layout.setHorizontalGroup(hg);
```

- **Ejemplo de GroupLayout secuencial (eje horizontal) y paralelo (eje vertical). Cada componente visualizado (1, 2, 3) pertenece a ambos grupos y se han añadido al grupo en orden incremental. Los espacios entre elementos en realidad no existirían:**

![62_11_Ejemplo_GroupLayout_secuencial_paralelo.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/62_11_Ejemplo_GroupLayout_secuencial_paralelo.png)

- **Ejemplo de GroupLayout secuencial (eje horizontal) y secuencial (eje vertical). Muestra cómo se ubicarían los componentes si los dos grupos fuesen secuenciales en los dos ejes:**

![62_12_Ejemplo_GroupLayout_secuencial_secuencial.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/62_12_Ejemplo_GroupLayout_secuencial_secuencial.png)

* * *

### 1.1.5. Creación de interfaces complejas

- **Ejemplo de combinación de layouts para generar una interfaz gráfica compleja:**

![62_13_Ejemplo_Combinacion_Layouts.png](https://github.com/sufigueroa87/Apuntes/blob/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/62_13_Ejemplo_Combinacion_Layouts.png)

- **Ejemplo de cómo combinar diferentes layouts para generar la calculadora mostrada anteriormente: combinamos BorderLayout con GridLayout:**

```Java
    //Contenidor d'alt nivell: finestra principal
    JFrame frame = new JFrame("Calculadora");
    JPanel panell = calculadora.getContentPane();
    panell.setLayout(new BorderLayout());
    ...
    JLabel display = new JLabel();
    display.setHorizontalAlignment(SwingConstants.RIGHT); 
    ...
    //Display de la calculadora a la zona superior
    panell.add(display, BorderLayout.NORTH);
    ...
    JPanel panellBotons = new JPanel();
    panellBotons.setLayout(new GridLayout(4, 4));
    JButton boto7 = new JButton("7");
    ...
    panell.add(boto7);
    ...
    //Panell de botons a la zona central
    panell.add(panellBotons, BorderLayout.CENTER);
    ...
```

- **Qué layout podemos usar si necesitamos hacer interfaces de composiciones muy complejas?**
    - los layouts de posicionamiento absoluto (layouts absolutos).
- **Qué sucede si redimensionamos la ventana usando layouts absolutos?**
    - Que todo sigue igual, no se redimensionan los componentes. Por tanto quedará un espacio sin nada al ampliar la ventana.
- **Ejemplo de redimensión de un layout absoluto:**

![62_14_Ejemplo_Redimension_Layout_Absoluto.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/62_14_Ejemplo_Redimension_Layout_Absoluto.png)

- **Se encuentran los layouts absolutos en las bibliotecas estándar de Java?**
    - NO, se necesita incluirlos como clases adicionales dentro de las aplicaciones que los usen porque sino no funcionarán.

* * *

## 1.2. Conexión de la interfaz con la aplicación

- **Qué sucede cuando un usuario da una orden en la interfaz gráfica?**
    - La orden se traduce en una interacción directa con los objetos que componen la lógica interna del programa, y cambia el estado de estos objetos.
- **Cuál es el objetivo principal al crear una interfaz gráfica para evitar que la modificación de una clase genere modificaciones en muchas otras clases?**
    - Es necesario separar las clases vinculadas a la interfaz de las vinculadas con la lógica interna (o estado de la aplicación).
- **Qué es el "caso ideal de interconnexión"?**
    - Es el caso en que las clases del modelo estático UML, resultado del proceso de diseño, se pueden integrar dentro de cualquier interfaz, sea cual sea la apariencia, sin tener que hacer absolutamente ningún cambio sobre estos.
- **Cómo podemos lograr que la aplicación final sea escalable y reutilizable?**
    - Necesitamos establecer una estrategia que se pueda usar en cualquier lenguaje de programación.

* * *

### 1.2.1. El patrón Modelo-Vista-Controlador

- **Qué usan muchos lenguajes de programación para interconnectar la lógica interna de la aplicación (generada en el proceso de diseño UML) con la interfaz de usuario?**
    - El patrón de diseño llamado Modelo-Vista-Controlador (MVC).
- **Qué es un patrón de diseño?**
    - Es una estrategia a seguir para resolver un problema determinado dentro del proceso de diseño del programario, de manera que se pueda usar en un amplio abanico de situaciones. Siempre es necesario adaptar esta estrategia a los detalles de cada caso concreto.
- **Cómo podemos evitar que las modificaciones de una parte de la aplicación impliquen cambios en otra parte de la aplicación?**
    - Con el Modelo-Vista-Controlador (MVC).
- **En cuantos conjuntos divide el patrón MVC las diferentes clases de la aplicación?**
    - En 3 conjuntos diferenciados, según el rol que tengan las clases.
- **Qué representan las clases del Modelo?**
    - Representan la lógica interna del programa.
- **Qué contienen las clases del Modelo?**
    - Contienen el estado de la aplicación.
- **Qué proporcionan las clases del Modelo?**
    - Proporcionan todas las funcionalidades exclusivas de la aplicación, independientes de la interfaz.
- **Por qué clases está compuesto principalmente el conjunto Modelo del MVC?**
    - Por las clases que el diseñador ha reflejado en el modelo estático UML.
- **Qué representan las clases de la Vista?**
    - Representan el aspecto puramente vinculado a la interfaz de usuario, gráfica o no.
- **De qué se encargan las clases de la Vista?**
    - De capturar las interacciones del usuario.
    - De acceder a los datos almacenados en el modelo.
    - Gracias a esto, el usuario puede visualizar y manipular correctamente la aplicación.
- **Cuál es una de las responsabilidades de las clases de la Vista?**
    - Mantener la consistencia entre los datos internos y lo que visualiza el usuario.
- **Qué implica que una clase sea usada para gestionar elementos donde visualizar información o dar órdenes a la aplicación?**
    - Que formarán parte del conjunto de clases de la Vista del MVC.
- **En qué conjunto pertenecen las clases que gestionan una impresora o un panel LED?**
    - Del conjunto Vista del MVC.
- **A qué conjunto del MVC pertenecen todos los componentes gráficos de Swing?**
    - Al conjunto Vista.
- **Qué representa el conjunto Controlador del MVC?**
    - Representa la capa intermedia entre datos e interfaz.
- **De qué se encargan las clases del conjunto Controlador del MVC?**
    - De traducir cada interacción del usuario (capturada por la Vista) en llamadas a métodos definidos en el Modelo, de manera que se ejecute la lógica interna adecuada a la orden dada por el usuario.
- **A qué corresponde cada funcionalidad de la interfaz?**
    - A una clase específica para dicha funcionalidad, que se encuentra en el conjunto Controlador.
- **Qué genera que la aplicación responda a las órdenes del usuario?**
    - Las interacciones de los objetos de las clases de los diferentes conjuntos del MVC.
- **Esquema de actuación de los elementos del patrón MVC:**

1.  1.  El usuario actúa sobre una instancia de una clase de la Vista, por ejemplo, un botón.
    2.  El objeto recibe la acción y la pasa a la instancia de una clase del Controlador. Aquí es donde se transmite toda la información adicional necesaria para el tratamiento correcto de la acción. Por ejemplo, si se hizo con el botón derecho o izquierdo del ratón, o si se hizo doble clic.
    3.  El objeto Controlador llama a los métodos que toquen del Modelo para lograr el resultado asociado a la acción del usuario.
    4.  El estado de los objetos del Modelo cambia.
    5.  El Modelo avisa a la Vista que han habido cambios.
    6.  Los objetos de la Vista que muestran la información asociada al estado del Modelo llaman a los métodos de consulta necesarios para mostrar correctamente el nuevo estado.

- **Resumen de las interacciones entre los objetos de los 3 conjuntos del MVC:**

![62_15_Resumen_Interacciones_3Conjuntos_MVC.png](.https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/62_15_Resumen_Interacciones_3Conjuntos_MVC.png)

- **Qué 2 beneficios principales aporta el uso del MVC?**
    - Más reutilización de las clases:
        - La separación entre las clases del Modelo y la Vista permite implementar más fácilmente aplicaciones en que hay diferentes mecanismos para visualizar la información en paralelo.
        - Esto también permite facilitar el test y el mantenimiento de estas clases, ya que todo el acceso al estado de la aplicación siempre se realiza mediante estas clases.
    - Mejor portabilidad en entornos heterogéneos:
        - La adaptación de la aplicación a nuevos sistemas diferentes con distintas capacidades para visualizar la información solo implica la implementación de una nueva Vista.
        - El Modelo se puede mantener íntegro sin que se necesite ninguna modificación.

* * *

### 1.2.2. Control de eventos

- **Qué sucede mientras la aplicación interactiva espera que el usuario haga alguna acción?**
    - La aplicación se queda parcialmente o totalmente inactiva.
- **A qué corresponden las llamadas asíncronas entre los objetos de la Vista y el Controlador?**
    - A los eventos.
- **Qué es lo que genera eventos?**
    - Las acciones del usuario sobre componentes Swing.
- **A qué se asocian los eventos?**
    - A fragmentos de código que se ejecutan cada vez que los eventos tienen lugar.
- **Qué define Swing para representar cada tipo de interacción?**
    - Una clase. Todas las clases para representar los distintos tipos de interacción se encuentran en java.awt.event.
- **Los 6 eventos más típicos (6 clases de java.awt.event):**
    - ActionEvent
    - MouseEvent
    - KeyEvent
    - WindowEvent
    - FocusEvent
    - TextEvent
- **ActionEvent**:
    - Se genera en realizar al acción más típica, o estándar, sobre un control.
    - Cada control establece cuál considera que es su acción estándar, que puede ser distinta en cada caso.
    - Por ejemplo, un botón se genera al pulsarlo.
- **MouseEvent:**
    - Generado frente cualquier acción vinculada exclusivamente al ratón.
    - Por ejemplo, pulsar cualquier botón del ratón, mover el apuntador dentro de un área concreta, etc.
- **KeyEvent:**
    - Asociado a acciones exclusivamente relativas al teclado.
    - Por ejemplo, pulsar una tecla o dejarla ir.
- **WindowEvent:**
    - Cualquier evento relativo al estado de una ventana.
    - Por ejemplo, minimizarla, maximizarla, redimensionarla o cerrarla.
- **FocusEvent:**
    - Viene dado por acciones vinculadas al focus de controles.
    - Con focus se refiere al hecho que un control queda remarcado dentro de la interfaz, de manera que se puede interactuar directamente mediante el teclado.
    - Ejemplos de este tipo de evento son ganar o perder el focus.
- **TextEvent:**
    - Generado en realizar acciones relativas a campos de texto.
    - Por ejemplo, modificar un campo de texto.
- **Todos los componentes Swing pueden generar absolutamente todos los tipos de eventos?**
    - No, solo pueden generar los eventos asociados a las interacciones que pueden recibir.
- **Ejemplo de evento: MouseEvent:**

![62_16_Ejemplo_Acontecimiento_MouseEvent.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/62_16_Ejemplo_Acontecimiento_MouseEvent.png)

* * *

### 1.2.3. Captura de eventos

- **Mediante qué tipo de objetos especiales se realizan las capturas de eventos dentro de la aplicación?**
    - Los objetos Listeners.
- **Qué conforman los Listeners?**
    - La parte del Controlador del patrón MVC plasmado en la biblioteca gráfica de Java.

### Listeners

- Cuantos tipos de Listeners hay?
    - Uno diferente para cada tipo de evento:
        - objetos ActionListener: capturan eventos de tipo ActionEvent.
        - objetos MouseListener: capturan eventos de tipo MousEvent.
        - etc.
- **Qué tipo de evento puede asociar cada Listener?**
    - Solo el tipo de evento al cual está asociado.
- **Un Listener puede capturar eventos de distintos componentes de dentro de la interfaz gráfica?**
    - No, solo puede capturar el evento que genera un único componente.
- **Qué necesitamos hacer para que un Listener capture el evento que genera un componente de dentro de la interfaz gráfica?**
    - Necesitamos registrar el Listener en el componente.
- **Qué sucede si para un tipo concreto de evento el componente no tiene ningún Listener asociado registrado?**
    - Los eventos se ignorarán y no sucederá nada en la aplicación.
- **Cómo podemos hacer el registro de un Listener a un componente?**
    - Mediante un método específico para el tipo de evento que se vaya a generar. El propio componente dispone de este método.
- **De qué método disponen los componentes que generan ActionEvent para poderles registrar un Listener que recoja el evento?**
    - Del método addActionListener.
- **De qué se encargan los objetos Listener?**
    - Son los encargados de capturar los diferentes tipos de eventos, adoptando el rol de Controlador del patrón MVC.
- **Cómo pueden los objetos Listener capturar los diferentes tipos de evento?**
    - Necesitan estar registrados a los componentes que generan los eventos a capturar.
- **Si un componente genera varios eventos distintos, cuantos Listeners tiene que tener registrados?**
    - Tantos Listeners como eventos genere.
- **Ejemplo de registro de Listeners y captura de eventos:**

![62_17_Ejemplo_Listeners_Captura_Eventos.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/62_17_Ejemplo_Listeners_Captura_Eventos.png)

- **Ejemplo de algunos Listeners típicos, con sus métodos definidos:**

![62_18_Ejemplo_Listeners_Metodos.png]()

- **Qué sucede cuando un Listener captura un evento?**
    - Inmediatamente llama al método correspondiente a la acción más concreta que ha llevado a cabo la generación del evento.
- **Si por ejemplo se genera un MouseEvent por pulsar el botón del ratón, qué sucede inmediatamente?**
    - Se produce la llamada al método mouseClicked, que corresponde a la acción más concreta que ha llevado a cabo la generación del evento MouseEvent.
- **Ejemplo de llamada de los métodos a los Listeners:**

![62_19_Ejemplo_LlamadaMetodos_Listeners.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/62_19_Ejemplo_LlamadaMetodos_Listeners.png)

- **Cómo se encuentran definidos los diferentes tipos de Listener dentro de la biblioteca gráfica de Java?**
    - Como interfaces.
- **Cómo se puede instanciar un objeto Listener?**
    - Como los tipos Listener son interfaces, el desarrollador tiene que crear una clase propia que implemente la interfaz correspondiente y, por tanto, codificar mediante sobreescritura todos y cada uno de los métodos definidos en la interfaz correspondiente.
- **Qué es entonces el objeto Listener que se registra a un componente?**
    - Es una instancia de la clase creada por el desarrollador que implementa la interfaz del tipo de Listener concreto.
- **Qué es lo que hace posible que la biblioteca gráfica de Java pueda ser adaptada a cualquier aplicación?**
    - El polimorfismo, ya que se pueden sobreescribir métodos y en esta sobreescritura podemos definir lo que necesitamos que haga el método específico para el funcionamiento de nuestra aplicación.
- **Qué implica que el código asociado a una misma acción en diferentes componentes sea distinto?**
    - Que el desarrollador tendrá que crear una clase propia Listener para cada tipo de evento y para cada tipo de componente dentro de la interfaz gráfica.
- **Por ejemplo, si tenemos 3 botones y queremos asignar a cada botón un código distinto, cuantas clases que implementen la interfaz ActionListener tendremos que crear?**
    - 3 clases distintas, una para cada Listener. De cada una de estas clases crearemos una instancia que posteriormente registraremos a cada componente botón.
    - En cada una de las clases creadas que implementan la interfaz ActionListener, sobreescribiremos el método actionPerformed, modificándolo según lo que necesitemos que haga dicho método (y en consecuencia cada distinto botón).
- **Asignación de código a los eventos usando métodos polimórficos y usando el patrón MVC:**

![62_20_Asignacion_Codigo_Eventos_MetodosPolimórficos_MVC.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/62_20_Asignacion_Codigo_Eventos_MetodosPolim%C3%B3rficos_MVC.png)

- **Si tenemos distintos componentes que generan el mismo tipo de evento, podemos reutilizar el objeto Listener que recoge este tipo de evento?**
    - Sí.
- **Qué aporta que todos los Listeners se definan como clases internas?**
    - Al definir los Listeners como clases internas, se consideran clases auxiliares de la interfaz gráfica. Así, evitamos tener una cantidad enorme de clases en ficheros .java.
    - Desde el código de los Listeners podemos acceder directamente a los atributos de la interfaz gráfica.
- **Cómo podemos acceder directamente a los atributos de la interfaz gráfica, teniendo en cuenta que no podemos llamar a métodos de objetos del modelo sin tener una referencia?**
    - A través del código de los Listeners.
- **Ejemplo de interfaz gráfica CalculadoraGUI:**

```Java
    public class CalculadoraGUI {
     
      //Model
      private Calculadora calculadora = new Calculadora(); 
      //Display consulta estat del Model per inicialitzar-se
      private JLabel display = 
                     new JLabel(Float.toString(calculadora.getDisplay()));
     
      private class B1ActListener implements ActionListener {
        public void actionPerformed(ActionEvent e){
          calculadora.pitjarNumero(1);
          display.setText(
          Float.toString(calculadora.getDisplay()));
        }  
      }
      ...
      private class SumActListener implements ActionListener {
        public void actionPerformed(ActionEvent e){
          calculadora.pitjarOperacio(Calculadora.SUMA);
          display.setText(
          Float.toString(calculadora.getDisplay()));
        }  
      }
      ...
      private class ResActListener implements ActionListener {
        public void actionPerformed(ActionEvent e){
          calculadora.reset();
          display.setText(
          Float.toString(calculadora.getDisplay()));
        }
      }
      ...
      JButton boto1 = new JButton("1");
      boto1.addActionListener(new B1ActListener());
      ...
      JButton botoSuma = new JButton("+");
      botoSuma.addActionListener(new SumActListener());
      ...
      JButton botoC = new JButton("C");
      botoC.addActionListener(new ResActListener());
      ...
    }
```

- **Ejemplo de reutilización de un mismo objeto Listener en diferentes componentes:**

```Java
    private class BotoNumeroListener implements ActionListener {
      public void actionPerformed(ActionEvent e) {
        JButton botoPitjat = (JButton)e.getSource();  
        calculadora.pitjarNumero(
        Integer.parseInt(botoPitjat.getText()));
        display.setText(
        Float.toString(calculadora.getDisplay()));
      } 
    }
    ...
    //S'instancia un únic Listener                    
    ActionListener botoNumeroListener = new BotoNumeroListener();
    //Es generen els 10 botons numèrics amb un bucle
    for (int i=0;0<10;i++) {
      JButton boto = new JButon(Integer.toString(i));
      //S'assigna sempre el mateix objecte Listener per tots
      boto.addActionListener(botoNumeroListener);
      panellBotons.add(boto);
      ...
    }
```

### Adaptadores

- **Qué implica que los Listeners son interfaces?**
    - Que el desarrollador está obligado a sobreescribir todos sus métodos sin ninguna excepción.
- **Qué tenemos que hacer si no queremos realizar ninguna acción en alguno de los métodos que vienen de la interfaz implementada?**
    - Será necesario dejar el método vacío.
- **Qué aporta la biblioteca gráfica de Java para no tener que sobreescribir todos los métodos de la interfaz Listener en la clase que la implementa?**
    - La biblioteca gráfica del Java define un conjunto de clases Listener no abstractas con todos los métodos ya sobreescritos, pero con el contenido vacío.
- **Cómo se llaman las clases Listener no abstractas que tiene la biblioteca gráfica de Java, creadas para no tener que sobreescribir todos los métodos de la interfaz Listener cuando queremos crear una clase que implementa Listener?**
    - Son las clases *adapter*.
- **Qué nos aporta usar las clases *adapter* de la biblioteca gráfica de Java para crear clases que implementen la interfaz Listener?**
    - Nos aporta SOLO tener que sobreescribir los métodos que queremos que usen los objetos de las clases que creemos. Los métodos que tiene la interfaz Listener que no queremos que usen nuestros objetos, no hará falta que los sobreescribamos.
- **Dónde se encuentran definidos los adaptadores?**
    - En el package java.awt.event.
- **Cuantos tipos de adaptadores hay?**
    - Hay un adapter para cada tipo de Listener con más de un método.
    - Algunos de estos adapters son:
        - FocusAdapter
        - WindowAdapter
        - KeyAdapter
        - etc.
- **Tienen clases adapter los Listeners que sólo tienen un método?**
    - No.
    - Algunos ejemplos de Listeners que no tienen adapters son:
        - ActionListener
        - TextListener

### Clases anónimas

- **Qué es una clase anónima?**
    - Es una clase que no tiene nombre.
    - Se caracteriza porque en lugar de definirse como una entidad diferenciada con una cabecera class, se define dentro del código justo en el momento preciso de instanciarla.
- **Pueden las clases anónimas tener acceso directo a cualquier atributo de la clase en que se definen?**
    - Sí.
- **Qué es necesario para poder crear una clase anónima?**
    - Que la clase que queremos definir sea subclase de otra ya existente.
- **Sintaxis para crear una clase anónima:**

```Java
    new NomSuperclasse() {
      //Definició normal de la classe (atributs + mètodes)
    }
```

- **Ejemplo de creación de interfaz gráfica CalculadoraGUI definiendo clases anónimas:**

```Java
    public class CalculadoraGUI {
     
    //Model
    private Calculadora calculadora = new Calculadora(); 
     
    //Contenidor d'alt nivell: finestra principal
    JFrame frame = new JFrame("Calculadora");
     
    //Display consulta estat del Model per inicialitzar-se
    private JLabel display = 
                   new JLabel(Float.toString(calculadora.getDisplay()));
    ...
     
    JButton botoSuma = new JButton("+");
     
    //Classe anònima per Listener del botó de sumar
    botoSuma.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) { 
        calculadora.pitjarOperacio(Calculadora.SUMA);
        display.setText(
        Float.toString(calculadora.getDisplay()));
      } 
    });
    ...
    JButton botoC = new JButton("C");
     
    //Classe anònima per Listener del botó de reset
    botoC.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        calculadora.reset(); 
        display.setText(
        Float.toString(calculadora.getDisplay()));
      }                              windowClosing
    });
    ...
    //Gestio el tancament de la finestra principal
    frame.addWindowListener(new WindowAdapter() { 
      public void windowClosing(WindowEvent e) {            
        System.exit(0); 
      }                          
    }); 
    ...
    }
```

* * *

## 1.3. Otros elementos gráficos

### 1.3.1. Paneles de opciones

- **Para qué sirven los paneles de opciones?**
    - Para avisar al usuario de algún evento o pedirle confirmación para realizar alguna acción.
- **Ejemplo de panel de opción:**

```Java
    JFrame finestra = new JFrame();
    ...
    int resposta = JOptionPane.showConfirmDialog(finestra,
      "Fitxer ja existent. Vol sobreescriure'l realment?",
      "Sobreescriure fitxer",
      JOptionPane.YES_NO_CANCEL_OPTION,
      JOptionPane. QUESTION_MESSAGE);
     
    switch(resposta) {
      case JOptionPane.YES_OPTION: 
        //Acció per SÍ 
        break;
      case JOptionPane.NO_OPTION: 
        //Acció per NO 
        break
      default: 
        //Acció per CANCELAR
    }
```

![62_21_Panel_Opcion.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/62_21_Panel_Opcion.png)

- **Cómo podemos realizar un panel de opciones?**
    
    - No es necesario crear una ventana y añadir todos los componentes uno a uno, ya hay una clase que los construye automáticamente y los muestra por pantalla: la clase JOptionPane.
- **Qué particularidad importante presenta la clase JOptionPane respecto a los otros mecanismos emprados por Swing?**
    
    - Que una gran parte de sus métodos son estáticos.
- **A qué está vinculado cada método de la clase JOptionPane?**
    
    - A la generación de un tipo de panel de opciones diferentes.
- **Por tanto, cómo podemos generar un panel de opción?**
    
    - Llamando a uno de sus métodos. No se suelen usar constructores.
- **En qué caso debemos usar método constructor para generar un panel de opción?**
    
    - Cuando queremos generar un panel de opción personalizado.
- **4 métodos estáticos de la clase JOptionPane para generar distintos tipos de paneles de opción:**
    
    - showConfirmDialog
    - showInputDialog
    - showMessageDialog
    - showOptionDialog
- **showConfirmDialog**:
    
    - Muestra un panel de confirmación, en que se pueden establecer distintas posibilidades de respuesta:
        - Sí/No
        - Sí/No/Cancelar
        - Aceptar/Cancelar
- **showInputDialog:**
    
    - Muestra un panel en que el usuario puede introducir una única línea de texto.
- **showMessageDialog:**
    
    - Muestra un mensaje al usuario, que solo puede aceptar.
- **showOptionDialog:**
    
    - Permite mostrar cualquier tipo de panel. El listado de parámetros permite personalizar todas las propiedades.
- **Qué devuelven los métodos estáticos de la clase JOptionPane para generar distintos tipos de paneles de opción?**
    
    - Devuelven el valor correspondiente a la respuesta dada por el usuario.
- **5 constantes de la clase JOptionPane que permiten al desarrollador establecer el comportamiento del panel de opción:**
    
    - JOptionPane.YES_OPTION
        - si el usuario ha pulsado que sí.
    - JOptionPane.NO_OPTION
        - si el usuario ha pulsado que no.
    - JOptionPane.CANCEL_OPTION
        - si el usuario ha pulsado cancelar.
    - JOptionPane.OK_OPTION
        - si el usuario ha pulsado ok.
    - JOptionPane.CLOSED_OPTION
        \- si el usuario ha cerrado el panel.
- **Qué devuelve el método showInputDialog de la clase JOptionPane?**
    
    - Devuelve un String con el valor introducido por el usuario.
    - Si la acción se cancela, devuelve null.
- **5 constantes de la clase JOptionPane que permiten indicar qué tipo de panel (*messageType*) se muestra, reflejado en un icono diferente (símbolo de exclamación, una señal de información, etc.):**
    
    - JOptionPane.ERROR_MESSAGE
    - JOptionPane.INFORMATION_MESSAGE
    - JOptionPane.WARNING_MESSAGE
    - JOptionPane.QUESTION_MESSAGE
    - JOptionPane.PLAIN_MESSAGE
- **Qué genera la constante PLAIN_MESSAGE?**
    
    - No genera ningún icono, deja el espacio en blanco.
- **3 constantes de la clase JOptionPane que permiten establecer qué combinaciones de botones deben aparecer en el panel (*optionType*):**
    
    - JOptionPane.YES\_NO\_OPTION
    - JOptionPane.YES\_NO\_CANCEL_OPTION
    - JOptionPane.OK\_CANCEL\_OPTION
- **Ejemplo de código para generar un panel de opción:**
    

```Java
    JFrame finestra = new JFrame();
    ...
    int resposta = JOptionPane.showConfirmDialog(finestra,
      "Fitxer ja existent. Vol sobreescriure'l realment?",
      "Sobreescriure fitxer",
      JOptionPane.YES_NO_CANCEL_OPTION,
      JOptionPane. QUESTION_MESSAGE);
     
    switch(resposta) {
      case JOptionPane.YES_OPTION: 
        //Acció per SÍ 
        break;
      case JOptionPane.NO_OPTION: 
        //Acció per NO 
        break
      default: 
        //Acció per CANCELAR
    }
```

* * *

### 1.3.4. Clases basadas en modelos

- **Qué son las clases basadas en modelo?**
    - Son clases que están vinculadas a un Modelo.
- **Cómo podemos cambiar el aspecto de controles que integran directamente el patrón MVC en su código (ya que se vinculan a un Modelo)?**
    - Interactuando con dicho Modelo.
- **Cómo podemos modificar el aspecto de una clase basada en Modelo?**
    - Asignándole un Modelo a su constructor o mediante el método setModel, e interactuando con este Modelo.
- **Cómo sabemos qué Modelo tenemos que asignar a un constructor de una clase basada en Modelo?**
    - Cada clase basada en Modelo define la propia clase a usar como a Modelo y los métodos que se pueden llamar.
- **Qué particularidad tienen los Modelos de las clases basadas en Modelo?**
    - Que pueden almacenar Listeners, de manera que es posible avisar al motor gráfico de Java siempre que se de alguna modificación. Cuando esto sucede, el motor gráfico de Java llama a métodos consultores para ver cuál ha sido la modificación y para actualizar los valores presentados por pantalla.

### JList

- **A qué corresponde la clase JList?**
    - A un listado de elementos, del cual se puede seleccionar uno o más.
- **Cómo podemos añadir elementos a JList?**
    - Mediante su Modelo.
- **Cuál es el Modelo definido para interactuar con JList?**
    - La interfaz ListModel.
- **Como el Modelo para interactuar con JList es una interfaz, qué tendremos que hacer para interactuar con JList?**
    - Crear una implementación de acuerdo con las necesidades. Esta instancia creada es la que asigna a JList.
- **Qué 4 métodos públicos define JList?**
    - Object getElementAt(int index)
    - int getSize()
    - void removeListDataListener(ListDataListener l)
    - void addListDataListener(ListDataListener l)
- **Object getElementAt(int index):**
    - Obtiene el elemento almacenado en la posición *i* de la lista.
    - El texto que se visualiza en la JList es el resultado de llamar al método toString sobre el objeto devuelto.
- **int getSize():**
    - Obtiene el número de elementos almacenados en la lista.
- **void removeListDataListener(ListDataListener l):**
    - Elimina un Listener asociado.
- **void addListDataListener(ListDataListener l):**
    - Los métodos asociados a la gestión de los Listeners registrados.
- **Qué finalidad tienen los métodos públicos de la interfaz ListModel?**
    - Son métodos consultores de lectura, los mínimos indispensables para poder descubrir qué información se tiene que representar por pantalla.
- **Qué 2 subclases proporciona Swing para ahorrarnos la faena de implementar los métodos definidos en la interfaz ListModel?**
    - La clase abstracta AbstractListModel:
        - Están codificados todos los aspectos vinculados al registro de Listeners, de manera que si se hereda directamente de ella solo necesitaremos implementar los métodos getElementAt y getSize, y llamar al método fireContentsChanged siempre que los datos del Modelo se modifiquen.
    - La clase DefaultListModel:
        - Implementa absolutamente toda la interfaz, de manera que la instancia se comportará por defecto igual a un vector.
- **Qué sucede cuando llamamos a fireContentsChanged?**
    - El motor gráfico de Java se encarga de actualizar el componente gráfico de acuerdo con los valores almacenados en el Modelo.
- **Ejemplo de código para generar una JList correctamente a partir de un Modelo, en este caso partiendo de la clase AbstractListModel:**

```Java
    ...
    private class MyListModel extends AbstractListModel {        
      int[] valors = {1,2,3,4,5};
     
      public Object getElementAt(int i) {
        return "Valor = " + valors[i]; 
      }
     
      public int getSize() { 
        return valors.length; 
      }
     
      public void incrementar() { 
        for (int i=0;i < valors.length; i++) valors[i]++; 
        //Avisar que s'ha modificat el model
        fireContentsChanged(this, 0, valors.length);
     } 
    }
    ...
    JList list = new JList(new MyListModel);
```

### JTable

- **Qué muestra la clase JTable?**
    - Muestra una tabla como la que se podría generar en una hoja de cálculo.
- **Qué Modelo asociado tiene JTable?**
    - La interfaz TableModel.
- \*\*Qué 3 métodos se definen en la interfaz TableModel? \*\*
    - int getRowCount():
        - devuelve el número de filas de la tabla.
    - int getColumn():
        - devuelve el número de columnas de la tabla.
    - Object getValueAt(int row, int column):
        - devuelve el elemento almacenado en la celda de la fila row y columna column.
        - Lo que visualizamos al llamar a este método es el resultado de llamar al método toString sobre el objeto devuelto.
- **Ejemplo de una JTable con un modelo asociado que indica que se compone de 3 filas y 4 columnas:**

```Java
    import javax.swing.table.*;
    ...
    private class MyTableModel extends AbstractTableModel {
      //Per una taula de 3 files * 4 columnes
      int[][] valors = 
      {{1,2,3,4}, {5,6,7,8}, {9,10,11,12}};
     
      public int getRowCount() { 
        return valors.length; 
      }
      public int getColumnCount(){ 
        return valors[0].length; 
      }
      public Object getValueAt(int row, int column){ 
        return "Valor = " + valors[row][column];
      }
      public void incrementar() { 
        for (int i=0;i < valors.length; i++) 
          for (int j=0;j < valors[i].length; j++) 
            valors[i][j]++; 
        //Avisar que s'ha modificat el model
        fireTableDataChanged();
      } 
    }
    ...
    JTable table = new JTable(new MyTableModel);
```

![62_22_Ejemplo_JTable.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/62_22_Ejemplo_JTable.png)

- **Qué 2 subclases proporciona Swing para ahorrarnos la faena de implementar los métodos definidos en la interfaz TableModel?**
    - AbstractTableModel:
        - proporciona una implementación parcial.
    - DefaultTableModel:
        - proporciona una implementación completa con un comportamiento por defecto.
- **Dónde encontramos definidos los dos métodos anteriores?**
    - Se encuentran definidos juntamente con el Modelo dentro del paquete javax.swing.table.

### JTree

- **Qué muestra la clase JTree?**
    - Muestra un árbol desplegable de elementos, de manera que si pulsas encima de uno se muestran u ocultan todos sus hijos de manera commutada.
- **Qué Modelo utiliza JTree?**
    - La interfaz TreeModel, definida en el paquete javax.swing.tree.
- **Por qué este Modelo es más complejo que los anteriores?**
    - Porque utiliza un conjunto de clases auxiliares (TreeNode y sus subclases).
- **Qué es recomendable hacer si queremos usar JTree?**
    - Usar la implementación por defecto que ofrece Java, que en este caso solo es una clase: DefaultTreeModel.
- **A qué corresponde lo que se visualiza al usar JTree?**
    - Al valor devuelto por la llamada al método toString.
- **Ejemplo de JTree con un modelo asociado compuesto por jerarquía de nodos. Cada nodo tiene asociada una cadena de texto, que es la que se visualiza en la interfaz gráfica:**

```Java
    import javax.swing.tree.*;
    ...
    private class MyTreeModel extends DefaultTreeModel {
      int[] valors = {1,2,3,4,5,6};
      DefaultMutableTreeNode[] nodes = new DefaultMutableTreeNode[6];
      public MyTreeModel() {
        super(new DefaultMutableTreeNode("Arrel"));
        DefaultMutableTreeNode arrel = (DefaultMutableTreeNode)getRoot();
        for (int i=0; i< nodes.length; i++)
          nodes[i] = new DefaultMutableTreeNode("Valor = " + valors[i]);
        arrel.add(nodes[0]);
        nodes[0].add(nodes[1]);
        nodes[0].add(nodes[2]);
        arrel.add(nodes[3]);
        nodes[3].add(nodes[4]);
        nodes[3].add(nodes[5]);
      }
      public void incrementar() {
        for (int i=0; i<nodes.length; i++) {
          valors[i]++;
          nodes[i].setUserObject("Valor = " + valors[i]);      
          //Avisar que s'ha modificat el model
          this.nodeChanged(nodes[i]); 
        }
      } 
    }
    ...
    JTree tree = new JTree(new MyTreeModel());
```

![62_23_Ejemplo_JTree.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/62_23_Ejemplo_JTree.png)
