# POO _ U1.1 _ FONAMENTS DE LA POO

# INTRODUCCIÓ

- **problemes que ens trobem els desenvolupadors:**
    - decidir com traduir el problema que hem de resoldre en les estructures de dades
    - manera en que les dades han d’interactuar entre sí
    - manera com les dades han de ser processades per l’ordinador
- **Què permet l’orientació a objectes?**
    - facilitar associar cada dada a un tipus de dada que l’ordinador sàpiga interpretar
- **En què es basa l’orientació a objectes?**
    - en la resolució de problemes mitjançant la seva descomposició en els elements fonamentals que els componen
    - en l’especificació de com interactúen els elements fonamentals que componen els problemes

# RESUM

- **Què és la metodologia de l’orientació a objectes?**
    - és una eina per resoldre problemes i desenvolupar aplicacions d’una manera propera al pensament humà
- **Quin és un dels avantatges principals de la metodologia de l’orientació a objectes?**
    - permet plantejar una solució inicial des d’un punt de vista de disseny, sense haver de codificar res
- **Quina és la clau de la metodologia de l’orientació a objectes?**
    - tot problema es pot plantejar com una simulació d’un escenari en el món real
- **Què és un objecte?**
    - cada element rellevant
- **Què té especificat cada objecte?**
    - unes característiques essencials, que són els atributs
- **Què aporten els atributs dels objectes?**
    - les propietats dels objectes
- **Què aporten les operacions?**
    - El comportament de l’objecte, o la manera en què pot interactuar dins la simulació
- **Com s’aconsegueix resoldre un problema?**
    - amb la interacció dels objectes entre ells i invocant operacions entre ells
- **Què són les classes?**
    - diferents conjunts d’objectes amb característiques comunes
- **Què és un objecte?**
    - una instància d’una classe
- **Què permeten els mapes d’objectes?**
    - permeten generar un esquema de l’estat d’un programa en un moment donat de la seva execució, tal com es plasmaria a la memòria, indicant quins són els enllaços existents entre instàncies
- NOMÉS PODEN INTERACTUAR OBJECTES ENLLAÇATS
- **Elements que s’aprecien en la definició d’una classe:**
    - la capçalera de la classe incorpora la paraula reservada **class** i el **nom de la classe**
    - en l’interior de la classe trobem:
        - **dades**
        - **iniciadors**
        - **mètodes**
- **Com poden ser els modificadors d’accés que incorporen les dades i els mètodes?**
    - public: es permet que el membre sigui accessible des de qualsevol classe
    - private: es prohibeix l’accés al membre des de qualsevol classe
- **Quins 2 modificadors poden incorporar les dades a més del modificador d’accés(public, private)?**
    - el modificador final: la dada passa a ser constant, de manera que una vegada ha agafat valor ja no el pot canviar
    - el modificador static: la dada passa a ser compartida (dada global) per tots els objectes de la classe
- **Quan es creen les dades que tenen modificadors final o static?**
    - es creen en el moment en què es carrega la classe malgrat no hi hagi cap instància (objecte) de la classe
- **Quin valor tenen les dades corresponents a tipus primitius de tipus numèriques que no tenen cap valor d’inicialització?**
    - 0
- **Quin valor tenen les dades corresponents a tipus primitius de tipus boolean que no tenen cap valor d’inicialització?**
    - null
- **Què són els iniciadors?**
    - blocs de codi que s’executen segons les regles següents:
        - si és **static**: únicament s’executa quan la classe es carrega (per tant, una única vegada)
- **Estructura de la definició d’una classe:**

```java
[public] class NomClasse [extends ClasseBase] [implements Interfície1, Interfície2...] {    
[modificadorAccés][final][static] tipusDada nomDada [=<valorInicial>];    
...    
[static] {<blocIniciador>}    
...    
[modificadorAccés][final][static] tipusRetorn nomMètode (<llistaArs>);    
... 
}
```

![58_00_Mapa_Conceptual.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_00_Mapa_Conceptual.png)

## FONAMENTS DE LA PROGRAMACIÓ ORIENTADA A OBJECTES

## 1.1. UN MÓN ORIENTAT A OBJECTES

- codis de menys a més astracció:
    - **codi màquina**: cadenes de 0 i 1 que s’executen directament dins del maquinari
    - **llenguatge assemblador**: no deixa de ser un conjunt de mnemotècnics que reemplacen els 0 i els 1 del codi màquina amb sentències més intel·ligibles per als humans.
        - fer un programa amb assemblador implicaria invertir molt de temps i resultaria en una dificultat enorme per depurar-lo, ampliar-lo en el futur o perquè algú altre el pogués entendre.
    - **llenguatges estructurats i la programació modular:** per exemple, llenguatges C, Pascal o Basic, juntament amb les seves biblioteques, on hi ha sentències que ens permeten fer des d’operacions matemàtiques simples fins a imprimir directament cadenes de text per pantalla.
        - Ja no cal conèixer tots els detalls del maquinari i és possible fer tasques complexes de manera senzilla.
        - Tot i així, un programador que utilitzi aquestes eines encara ha de conèixer alguns aspectes lligats a la màquina o el sistema operatiu: com funciona la memòria d’un ordinador, per definir estructures de dades, o els mecanismes d’entrada i sortida, per accedir als fitxers, el teclat o la pantalla.
    - **orientació a objectes:** veritable aproximació entre la manera com un ésser humà pot estructurar un problema i com codificarlo en forma de programa, de manera que ambdós processos siguin, conceptualment, tan semblants com sigui possible.
        - l’orientació a objectes com a tal és una metodologia, o estratègia, amb vista al desenvolupament del programari.
- **Què és l’orientació a objectes?**
    - no és un tipus de llenguatge de programació. És una metodologia de treball per crear programes.
- **Un dels aspectes més importants de l’orientació a objectes és:**
    - analitzar els problemes que volem resoldre mitjançant aplicacions informàtiques com ho fariem al món real
- **Què ens aporta analitzar els problemes que volem resoldre amb l’ordinador de manera similar a com ho fariem al món real?**
    - possibilita aplicar mecanismes formals d’enginyeria al programari sense la necessitat d’implementar primer la solució.
        - permet treballar de la mateixa manera que altres disciplines afins a l’enginyeria ho fan dins el seu àmbit (mecànica, electrònica, arquitectura, etc.)
        - permet dissenyar l’aplicació de manera totalment independent del llenguatge de programació que s’utilitzarà.
        - el dissenyador ni tan sols no ha de saber programar necessàriament.

## 1.1.1. GÈNESI I EVOLUCIÓ DE L’ORIENTACIÓ A OBJECTES

- **Què és un programa?**
    - simulació d’un escenari del món real, en què un conjunt d’elements, els objectes, interactuen entre ells per dur a terme la tasca que es vol resoldre.
- **Quins llenguatges es poden considerar els originadors del concepte de programació orientada a objectes?**
    - els llenguatges Simula
- **Quin llenguatge va començar a usar el nom programació orientada a objectes?**
    - el llenguatge SmallTalk de l’empresa Xerox
- **Qui va crear un ordinador personal especialment dissenyat per suportar aplicacions gràfiques?**
    - Alan Kay, de la Universitat de Utah, inspirant-se en l’obra de Dahl i Nygaard
    - va vendre la idea a l’empresa Xerox, que va desenvolupar el llenguatge SmallTalk per crear aquest ordinador totalment gràfic
- **Segons Alan Kay, com es podia interpretar una interfície d’usuari?**
    - es podia interpretar com un conjunt d’elements comuns o peces amb unes propietats clarament definides (botons, finestres, menús, etc.) que porten a terme una tasca en interaccionar entre ells o amb l’usuari
- **Com es deia l’ordinador creat amb la idea d’Alan Kay per l’empresa Xerox fent servir el llenguatge SmallTalk?**
    - Dynabook
- **Quines són algunes de les millores que va aportar el llenguatge SmallTalk?**
    - permetia la possibilitat que els objectes tinguessin un comportament dinàmic:
        - ser creats, destruïts o que les seves propietats poguessin canviar al llarg de l’execució del programa.
    - la introducció del concepte herència: poder definir diferents tipus d’objecte, diferents classes, només especificant les diferències que hi ha entre ells.
- **Quina va ser l’evolució que va catapultar l’orientació a objectes com a metodologia ideal per desenvolupar interfícies gràfiques?**
    - que els objectes tinguessin comportaments dinàmics: ser creats, destruïts o que les seves propietats poguessin canviar al llarg de l’execució , ja que en una interfície gràfica
- **Què va passar als anys 1980?**
    - la metodologia de la programació orientada a objectes va començar a guanyar impuls
    - un seguit de llenguatges NO orientats a objectes com BASIC, Pascal o Fortran, van començar a incorporar aspectes de l’orientació a objectes, o bé a partir d’ells es va generar una versió orientada a objectes
- **Quin va ser el llenguatge màxim exponent de l’època, tant per popularitat com per complexitat a l’hora de fer programes?**
    - el llenguatge C++
- **Qui va crear el llenguatge C++?**
    - Bjorn Stroustrup a partir del llenguatge C
- **Quines aportacions del llenguatge C++ van tenir els llenguatges orientats a objectes?**
    - l’herència múltiple (la capacitat d’un objecte per aplicar herència a partir de més d’una classe)
- Quin llenguatge va aparèixer als 1990 inspirat en C/C++ però que intentava disminuir-ne la complexitat a l’hro
    - el llenguatge Java
- **Qui va desenvolupar Java?**
    - SUN Microsystems i publicat en la seva versió 1.0 l’any 1995
- **Quina va ser una de les innovacions més importants que aportava Java?**
    - l’execució sobre una MÀQUINA VIRTUAL
        - els programes, en lloc d’executar-se directament sobre un maquinari o sistema operatiu específic, s’executen sobre una programa especial que crea una capa d’abstracció. D’aquesta manera, un programa generat per Java es pot executar sobre qualsevol plataforma, fet que en maximitza la portabilitat, però a costa d’una eficiència menor. Un dels seus eslògans va ser la frase *“compile once, run everywhere”* (compila un cop, executa a tot arreu).
- **Quin avantatge aporta que Java executi sobre màquina virtual? I quin desavantatge té això?**
    - un programa generat per Java es pot executar sobre qualsevol plataforma, fet que en maximitza la portabilitat, però a costa d’una eficiència menor.
- **Factors principals de la popularitat de java:**
    - el fet que tingui màquina virtual va permetre enfocar el llenguatge Java a la programació d’aplicacions a Internet, en què hom es troba en un entorn de sistemes heterogenis.
    - incorporar la màquina virtual de Java a tots els navegadors i la possibilitat d’executar programes en Java des d’aquests

## 1.1.2. BASES DE L’ORIENTACIÓ A OBJECTES

- **Quines són les bases de l’orientació a objectes que va definir Alan Kay?**
    - Tot és un objecte, amb una identitat pròpia.
    - Un programa és un conjunt d’objectes que interactuen entre ells.
    - Un objecte pot estar format per altres objectes més simples.
    - Cada objecte pertany a un tipus concret: una classe.
    - Objectes del mateix tipus tenen un comportament idèntic.
- **A què ens referim quan parlem de les propietats d’un objecte?**
    - ens referim a les qualitats que es considera important quantificar i que defineixen l’aspecte o l’estat de l’objecte.
    - als **atributs**.
- **Què defineix el comportament de cada objecte?**
    - una llista amb el conjunt de les interaccions que pot rebre, cada una sempre d’acord amb una tasca que pot fer o un canvi d’estat (una bombeta es pot apagar i encendre, un botó pot ser pitjat, una finestra tancada, etc.).
- **Com s’anomena cada interacció que pot rebre un objecte?**
    - una interacció
- **Com diem que un objecte A vol interactuar amb un objecte B?**
    - A crida una operació de B
- **Què és una classe?**
    - és l’especificació formal de les propietats (els atributs) i el comportament esperat (la llista d’operacions) d’un conjunt d’objectes del mateix tipus, i que actua com una plantilla per generar cadascun d’ells.
- **Què és un objecte?**
    - és una **instància** d’una classe
- **Quan és instanciat un objecte?**
    - quan es crea dins l’aplicació.
    - És tot just en aquest moment quan s’usa la classe per generar l’objecte, tot determinant quin és el seu conjunt d’atributs i assignant un valor concret per a cada un.
- **Instància i objecte són termes equivalents?**
    - si
- **Quan un objecte és instanciat es pot canviar la seva classe?**
    - NO
- **Què és el que realment el programador genera?**
    - el codi font que serà:
        - les classes de cada objecte necessari dins el seu programa
        - el codi que instancia i organitza tots els objectes
- **Què cal fer quan volem referir-nos a una classe en un text o en un esquema?**
    - usarem el nom de la classe
    - per a les classes sempre se sol usar majúscula.
- **Què cal fer quan volem referir-nos a una instància d’una classe (un objecte)?**
    - usarem la nomenclatura nomObjecte:NomClasse
    - per exemple: bitllet1:Bitllet, jugador4:Jugador
    - Quant a la nomenclatura, en el cas dels objectes, la primera inicial sempre sol ser en minúscula.
- **Què cal fer si volem referir-nos a un objecte qualsevol d’una classe determinada?**
    - :NomClasse
- **Què és una operació?**
    - és una funció o transformació que es pot aplicar a tots els objectes d’una classe.

**JOC DEL MONOPOLY: DESCRIPCIÓ**

- 1 _ **Tot és un objecte, amb una identitat pròpia:**
    
    - intentar crear la simulació d’un escenari que podríem tenir en el món real, però dins de l’ordinador
    - Aquesta simulació s’estructura en un conjunt d’elements, cadascun del quals té unes propietats i un comportament concret que intenten imitar les de l’element del món real que representen.
    - Aquests elements dins la simulació s’anomenen **objectes**. Així, doncs, en el programa en execució, tot element serà sempre un objecte.
    - **cada objecte és unic**
    
    ![58_01_Descomposición_En_Objetos.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_01_Descomposici%C3%B3n_En_Objetos.png)
    
    - cada element individual és representat per un objecte
    - si tenim tretze fitxes d’hotel, també hi haurà tretze objectes hotel
    - està expressat per les diferents representacions tipus **objecte1:**, …, **objecteN**: (per exemple, **fitxa1:** , …, **fitxaN:** en la figura)
    - entre els objectes hi haurà qualsevol element que formi part i interactuï dins d’una partida del joc
    - tot i que no apareix a la imatge, també cal tenir en compte elements com els jugadors o la banca.
- **2 _ Un programa és un conjunt d’objectes que interactuen:**
    
    - l’execució d’un programa vindrà donada pel conjunt d’interaccions entre els diferents objectes que el componen
    - podem interactuar amb un botó pitjant-lo
    - Aquest, a la vegada, interactuarà amb altres objectes (en el món real, potser amb una molla o enviant un senyal elèctric) per transmetre que cal executar una ordre donada.
    - Un programa en execució es compon d’un conjunt d’objectes que criden operacions entre ells.
    - un jugador pot fer les interaccions amb altres objectes del joc descrites en la taula 1. Cada interacció equival a cridar una operació sobre l’objecte que la rep.
    - També és possible que no sigui un altre objecte, sinó l’usuari de l’aplicació, qui cridi una operació sobre un objecte. Aquest aspecte cal tenir-lo en compte quan es defineixen les operacions que pot rebre un objecte.
    
    ![58_02_ALgunas_Interacciones_Iniciadas_Por_Objeto_Jugador.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_02_ALgunas_Interacciones_Iniciadas_Por_Objeto_Jugador.png)
    
- **3 _ Un objecte es pot compondre d’altres objectes més simples:**
    
    - la manera més senzilla de tractar amb la complexitat d’un problema és mitjançant la descomposició en problemes més simples.
    - es poden crear objectes que en realitat es componen d’altres de més simples.
    - Al Monopoly, un objecte fàcilment identificable és el tauler. Tot i així, també es pot considerar que aquest en realitat està format per la unió d’altres subelements més senzills: les caselles.
- **4 _ Cada objecte pertany a un tipus concret: una classe:**
    
    - hi ha objectes que es poden considerar del mateix tipus: tenen exactament les mateixes propietats, tot i que el valor de cada una pot ser diferent per a cada objecte concret, i el mateix comportament. Llavors es diu que aquests objectes pertanyen a la mateixa classe.
        
    - hi ha objectes que comparteixen unes propietats i un comportament, encara que el seu valor concret sigui diferent en cada cas:
        
        - tots els jugadors són el mateix tipus d’objecte (són el mateix, tot i que puguin tenir un valor diferent per a l’atribut nom)
        - podem detectar aquesta relació en els bitllets, els títols de propietat o les caselles del tauler, entre d’altres.
    - en el codi font del programa, el desenvolupador ha de generar una classe per a cadascun d’aquests tipus d’objectes: la classe `Jugador`
        , la classe `Bitllet`
        , la classe `Títol`
        , la classe `Casella`
        , etc. Només hi haurà una classe per a cada tipus d’objecte, i dintre seu es definirà quins són els atributs i quines són les operacions que es poden cridar sobre els objectes d’aquest tipus.
        
    - podem tenir quatre jugadors en una partida (en executar el programa), però el desenvolupador només haurà definit una única classe Jugador.
        
    - En començar la partida, el codi del programa s’encarregarà d’instanciar quatre objectes jugador, a partir de la classe Jugador, cadascun amb els seus valors concrets per als seus atributs (un nom diferent per a cadascun).
        
    - a partir d’una única classe Bitllet generem tots els objectes bitllet que hi ha quan el programa està en execució.
        
        ![58_03_Objetos_Instancia_De_Una_Clase.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_03_Objetos_Instancia_De_Una_Clase.png)
        
    - cada identificador d’objecte és únic (tot és un objecte, amb identitat pròpia).
        
    - Si usem el mateix identificador diverses vegades, en cada una es considerarà que ens referim exactament al mateix objecte.
        
- **5 _ Els objectes del mateix tipus tenen un comportament idèntic.**
    
    - De la mateixa manera que una classe defineix els atributs d’objectes del mateix tipus, també n’especifica el comportament: la seva llista d’operacions.
    - el conjunt d’interaccions possibles amb objectes de la mateixa classe sempre és el mateix.
    - Per cada interacció que un objecte de la classe A pot rebre (sense que importi el possible objecte origen), caldrà definir una operació associada a aquesta en especificar la classe A.

## 1.2. RESOLUCIÓ DE PROBLEMES USANT ORIENTACIÓ A OBJECTES

- tenir una idea de què compon realment un objecte i una classe
- com es poden especificar classes
- quins aspectes cal tenir en compte a l’hora de fer-ho
- **De què es composa un programa orientat a objectes?**
    - es composarà, al igual que una màquina, de la unió de cadascuna de les seves peces (les classes), que interactuant, faran que el tot funcioni.
- **Per què serveixen els mapes d’objectes?**
    - per visualitzar com, al final del procés, tot un conjunt de classes interactuen per tal de formar una aplicació

## 1.2.1 ESQUEMA GENERAL D’APLICACIÓ DE L’ORIENTACIÓ A OBJECTES

- **Quins passos ordenats hem de seguir per tal d’organitzar els components i els mecanismes necessaris per tal de resoldre un problema?**
    - 1 _ Plantejar l’escenari descriptivament, amb llenguatge humà. Com més detallada sigui la descripció, més fàcil serà la feina.
    - 2 _ Localitzar, dins la descripció de l’escenari, els elements que es consideren més importants: els que realment interactuen amb vista a resoldre el problema.
        - Aquests seran els objectes del programa. Normalment, solen ser substantius dins la descripció.
    - 3 _ Considerar quins elements són d’una certa complexitat. Redefinir-los com a agrupacions d’objectes més simples.
        - Una bona estratègia és partir del fet que tot l’escenari en si és un objecte complex (igual que una màquina també és un objecte complex) i anar-lo descomponent en parts més petites.
    - 4 _ Agrupar els diferents objectes segons el tipus: quins objectes veiem que tenen propietats o comportaments idèntics. Cada tipus d’objecte serà una classe que caldrà especificar.
    - 5 _ Identificar i enumerar les característiques dels objectes de cada classe: quines són les seves propietats (els atributs) i el seu comportament (les operacions que ofereixen). N’hi ha prou amb una llista general, escrita en llenguatge humà però suficientment entenedora.
    - 6 _ Establir les relacions que hi ha entre els objectes de les diferents classes a partir del paper que interpreten en el problema general.
        - Els objectes no es generen en un buit, sinó que estan relacionats entre si, de la mateixa manera que les peces d’una màquina o els elements d’un edifici no floten en l’aire, sinó que estan connectat per formar un tot.
        - De la mateixa manera, un cop identificats els objectes que conformen el problema a resoldre (el programa que es vol fer en aquest cas), cal identificar com es relacionen entre ells.
        - Normalment, aquesta mena d’enllaços es poden identificar com “aquest objecte en conté d’aquests altres” o “aquest objecte en gestiona aquests altres”. A mode d’ajut, es pot generar un **mapa d’objectes**.
    - 7 _ Per cada classe, especificar formalment els seus atributs i operacions, extrets a partir de la llista de propietats dels seus objectes dels punts 5 i 6. Normalment, especificar-ne els atributs és un procés més immediat que l’especificació de les operacions.
- **Què és el model de l’aplicació?**
    - És definir la lògica interna del sistema i com s’estructura la informació a processar. NO ha d’explicitar mai la interfície d’usuari a emprar.

## 1.2.2 EXEMPLES D’APROXIMACIONS ORIENTADES A OBJECTES

- el problema que es planteja en cada cas només es descriu de manera general, sense entrar a descriure en detall totes les funcionalitats.
- cada problema pot tenir diferents solucions, i totes poden ser totalment correctes.
- Tot depèn de la subdivisió en objectes que plantegi el dissenyador, segons la seva manera d’enfocar el problema proposat.

## EXEMPLE AGENDA

- 1 _ PLANTEJAR L’ESCENARI DESCRIPTIVAMENT:
    - Es vol dissenyar una agenda que permeti consultar les dates d’un calendari per a un any concret i apuntar cites a unes hores concretes.
    - Es pot pensar en l’agenda com un llibre en què es van passant pàgines endavant o endarrere, cadascuna de les quals correspon a un dia.
    - En cada pàgina es poden escriure cites establertes per a unes hores d’inici i de finalització determinades.
- 2 _ LOCALITZAR ELS ELEMENTS QUE ES CONSIDEREN MÉS IMPORTANTS: LOCALITZAR ELS OBJECTES
    - en aquest cas es pot partir d’un objecte *`agenda:`* i deduir els elements que el componen: les pàgines:
        
        ![58_04_Objetos_De_Una_Agenda.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_04_Objetos_De_Una_Agenda.png)
        
    - objectes pàgina: estàtic: 365
        
    - objectes cita: dinàmic: pot ser diferent per a cada instant de l’execució de l’aplicació, en iniciar l’aplicació no n’hi haurà cap i a mesura que avanci se n’hi afegiran, és a dir, s’aniran instanciant objectes cita
        
- 4 _ AGRUPAR ELS DIFERENTS OBJECTES SEGONS EL TIPUS: CADA TIPUS D’OBJECTE SERÀ UNA CLASSE
    - Classe Agenda: any
    - Classe Pàgina: dia, mes, si és dia festiu
    - Classe Cita: hora inici, hora finalització, motiu
- 5 _ IDENTIFICAR I ENUMERAR LES CARACTERÍSTIQUES DELS OBJECTES DE CADA CLASSE: QUINES SÓN LES PROPIETATS (ATRIBUTS) I EL SEU COMPORTAMENT (LES OPERACIONS QUE OFEREIXEN)
    - Agenda: passar pàgina endavant, passar pàgina endarrere.
    - Pàgina: escriure cita, esborrar cita.
    - Cita: escriure contingut.

ENLLAÇAMENTS objecte agenda

- Un objecte *`agenda:`* ha d’estar enllaçat amb els objectes *`pàgina:`*
     per poder gestionar-los.
- També ha de saber explícitament quina pàgina està oberta, que seria la pàgina que es pot llegir en aquest moment.
- Cada pàgina és qui s’encarrega d’emmagatzemar les cites que conté.

![58_05_Mapa_Objetos_De_Agenda.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_05_Mapa_Objetos_De_Agenda.png)

## EXEMPLE REPRODUCTOR MULTIMÈDIA

- en aquest exemple ja es deixarà de banda fer un paral·lelisme exacte entre el món real i els objectes i ens centrarem en els elements que realment aporten alguna cosa al funcionament del sistema.
    
- 1 _ PLANTEJAR L’ESCENARI DESCRIPTIVAMENT:
    
    - crear una aplicació senzilla per a l’ordinador o generar el sistema de control d’un reproductor portàtil (un dispositiu físic).
    - cal fer-se una idea clara de quin és el procés de reproducció d’una peça musical en llenguatge natural.
    - En el reproductor hi ha emmagatzemats fitxers multimèdia, el format dels quals no és important. Quan donem l’ordre de reproducció, el lector del sistema s’encarrega d’interpretar els **arxius multimèdia** i envia el resultat a l’**altaveu**, de manera que es poden escoltar. Les ordres es donen per mitjà d’un **tauler de control** (engegar, aturar, volum, etc.).
- 2 _ LOCALITZAR ELS ELEMENTS QUE ES CONSIDEREN MÉS IMPORTANTS: LOCALITZAR ELS OBJECTES
    
    - una bona estratègia per dividir els problemes mitjançant l’orientació a objectes és partir de la base que tot és un únic objecte, i anar cercant subelements.
    - objecte reproductor:
    - objectes subelements del reproductor: que fan que a l’interaccionar el sistema funcioni
        - molts objectes mèdia:
            - objectes altaveu
    
    ![58_06_Objetos_Del_Reproductor.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_06_Objetos_Del_Reproductor.png)
    
- 4 _ AGRUPAR ELS DIFERENTS OBJECTES SEGONS EL TIPUS: CADA TIPUS D’OBJECTE SERÀ UNA CLASSE: Partint de la llista d’objectes es poden identificar les classes
    
    - classe Reproductor
    - classe Altaveu
    - classe PannellControl
    - classe Lector
    - classe Magatzem
    - classe Mèdia
- 5 _ IDENTIFICAR I ENUMERAR LES CARACTERÍSTIQUES DELS OBJECTES DE CADA CLASSE: QUINES SÓN LES PROPIETATS (ATRIBUTS) I EL SEU COMPORTAMENT (LES OPERACIONS QUE OFEREIXEN)
    
    - ATRIBUTS:
        - `Mèdia`: dades, nom, artista, durada en segons, ubicació de les dades.
        - `Control`: volum, marxa/pausa.
        - `Lector`: mèdia en curs.
        - `Magatzem`: peces de mèdia.
    - MÈTODES:
        - `Magatzem`: mèdia següent, afegir mèdia, esborrar mèdia.
        - `Control`: apujar volum, abaixar volum, engegar, aturar, parar.
        - `Lector`: reproduir mèdia, aturar, parar.
        - `Altaveu`: generar so, establir volum.
- **Quina classe té mots atributs i poques operacions?**
    
    - la classe Mèdia
- **Quina classe té pocs atributs i moltes operacions?**
    
    - la classe Lector
- **Quin és l’objecte que està molt vinculat a l’entrada de dades?**
    
    - panellControl
    - les operacions del qual es pot considerar que venen cridades directament per l’usuari
- **Quin és l’objecte que servirà com a mecanisme de sortida?**
    
    - Altaveu

ENLLAÇAMENTS objecte reproductor

- Es decideix que el reproductor té dos altaveus, de manera que es pot controlar el mode mono o l’estèreo.
- L’objecte *`reproductor`* és el que controla tots els elements bàsics.
- En el que es refereix als objectes *`media:`*, els únics components que en fan alguna cosa són el magatzem i el lector.
- Del mapa, també s’extreu que en aquest moment n’hi ha cinquanta-quatre i s’està reproduint la darrera.

![58_07_Mapa_Objetos_Del_Reproductor.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_07_Mapa_Objetos_Del_Reproductor.png)

## EXEMPLE APLICACIÓ DE GESTIÓ

- 1 _ PLANTEJAR L’ESCENARI DESCRIPTIVAMENT:
    - Una empresa vol crear una aplicació que gestioni el transport d’**encàrrecs** d’una **sucursal** d’una franquícia. Cada sucursal té un conjunt de **transportistes** assignats, el nombre dels quals pot variar segons la grandària de la sucursal. Cada dia hi ha un transportista que no treballa, però es considera que està en reserva. Cada un disposa del seu propi vehicle, identificat per un número de llicència.
    - Quan un **client** vol fer un encàrrec, se n’enregistren les dades personals i aquest especifica les condicions de lliurament: dia i hora, adreça, etc. En l’encàrrec fa constar la llista de **productes** que vol que li serveixin. Tan bon punt es genera un encàrrec, automàticament ja s’assigna a algun transportista perquè el serveixi. Mai no hi ha encàrrecs sense transportista assignat.
    - Els clients també tenen l’opció de recomanar a amics seus perquè s’hi apuntin com a clients. Aquest fet es té en compte amb vista a algunes promocions o descomptes especials.
- 4 _ AGRUPAR ELS DIFERENTS OBJECTES SEGONS EL TIPUS: CADA TIPUS D’OBJECTE SERÀ UNA CLASSE: Partint de la llista d’objectes es poden identificar les classes
    - `Encàrrec`: dia, mes, hora.
    - `Sucursal`: nom, adreça postal, telèfon de contacte, adreça de correu electrònic.
    - `Transportista`: nom, telèfon mòbil, número de llicència.
    - `Client`: nom, adreça postal, telèfon de contacte, adreça de correu electrònic.
    - `TipusProducte`: codi identificador, preu, estoc, si ja és a la venda.
- 5 _ IDENTIFICAR I ENUMERAR LES CARACTERÍSTIQUES DELS OBJECTES DE CADA CLASSE: QUINES SÓN LES PROPIETATS (ATRIBUTS) I EL SEU COMPORTAMENT (LES OPERACIONS QUE OFEREIXEN)
    - `Encàrrec`: modificar data, afegir producte, esborrar producte
    - `Sucursal`: fer descansar transportista, alta de client, baixa de client
    - `Transportista`: assignar encàrrec, esborrar encàrrec
    - `Client`: modificar dades personals
    - `TipusProducte`: modificar preu, modificar estoc

**ENLLAÇAMENTS objecte aplicació de gestió**

- S’ha volgut representar el cas on hi ha tres transportistes disponibles a la sucursal.
- El que no té assignat cap encàrrec és el de reserva.
- Un transportista té assignats dos encàrrecs, mentre que l’altre només en té assignat un.
- La sucursal gestiona N clients i tipus de productes.
- Respecte els clients, es pot veure que dos de diferents, en els seus encàrrecs, demanen el mateix tipus de producte (*`tipusProducte1:`*
    ).
- Curiosament, el client 2 demana el mateix producte en dos encàrrecs diferents (*`tipusProducte2:`*).
- El client 1 no té cap encàrrec pendent ara mateix i és qui va fer una recomanació al client 2.

![58_08_Enlazamiento_Objeto_Acplicación_Gestión.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_08_Enlazamientos_Objeto_Aplicaci%C3%B3n_Gesti%C3%B3n.png)

## 1.2.3 MAPES D’OBJECTES

- **Com podem reflexionar sobre com els diferents objectes s’estructuren dins una aplicació?**
    - fent un esquema que representi alguns dels estats possibles dins l’aplicació al llarg de la seva execució, d’acord als objectes que hi participen.
- **Què es mostra en un mapa d’objectes?**
    - tots els objectes instanciats i els enllaços que hi ha entre ells en un moment determinat de l’execució, de manera coherent amb el que s’espera de l’aplicació.
- **Què cal perquè 2 objectes puguin interactuar entre ells?**
    - han d’estar enllaçats (igual que dues peces dins una màquina han d’estar vinculades entre si d’alguna manera per poder interactuar).
- **Què succeeix quan un objecte A crida una operació sobre un objecte B, a on afecten únicament les transformacions?**
    - les transformacions fetes per l’operació únicament afectaran l’objecte objecte B

## 1.3. ESPECIFICACIÓ COMPLETA DE LES CLASSES

- **Quin llenguatge usem per crear l’especificació formal de les classes de manera completa, amb els seus atributs i operacions, un cop tenim una idea més o menys clara de quins objectes formaran part del programa i com s’estructuren?**
    
    - el llenguatge UML
- **Què és l’UML?**
    
    - És un llenguatge estàndard que permet especificar amb notació gràfica programari orientat a objectes.
- **Com es representa una classe en UML?**
    
    - amb una caixa dividida horitzontalment en 3 parts.
    
    ![58_09_Reoresentación_Clase_UML.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_09_Representaci%C3%B3n_Clase_UML.png)
    

## 1.3.1. ESPECIFICACIÓ D’ATRIBUTS

- **Què permeten els atributs?**
    
    - permeten especificar les propietats o l’estat dels objectes d’una classe.
- **Què és un objecte?**
    
    - és un bloc de memòria, dins el qual es troben emmagatzemats tots els seus atributs.
- **Com s’especifiquen els atributs en definir una classe?**
    
    ```java
    visibilitat nomAtribut: tipus [= valor inicial]
    
    //valor inicial correspon al valor que pren l'atribut en el moment
    //od'instanciar un objecte d'aquesta classe
    
    ```
    
- **Què cal definir per a cada atribut en l’orientació a objectes?**
    
    - la seva visibilitat
- **Què és la visibilitat d’un atribut?**
    
    - indica si aquest és accessible directament des d’altres classes.
    - es refereix a l’accessibilitat a un objecte en l’àmbit del codi.
- **Quins 2 tipus de visibilitat trobem?**
    
    - pública
    - privada
- **Què és un atribut públic?**
    
    - s’identifica amb el símbol “+”
    - si una instància *`a:`* està enllaçada amb una instància *`b:`*, *`a:`* pot accedir lliurement als valors emmagatzemats en els atributs de *`b:`*.
- **Què és un atribut privat?**
    
    - s’identifica amb el símbol “-”
    - No es pot accedir a aquest atribut des d’altres objectes, independentment del fet que existeixi un enllaç o no.
    - A efectes pràctics, és com si no existís fora de l’especificació de la classe i, en conseqüència, només es pot utilitzar en les operacions dins de la mateixa classe en què s’ha definit.
- **A quins atributs pot accedir sempre un objecte , independentment de la seva visibilitat?**
    
    - als seus propis atributs
- **Quins són els tipus bàsics d’atributs?**
    
    ![58_10_Tipos_Básicos_Atributos.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_10_Tipos_B%C3%A1sicos_Atributos.png)
    
- **De quines 2 maneres es poden especificar els tipus múltiples?**
    
    - enter\[5\] indica que hi ha exactament cinc enters
    - enter\[0..5\] indica que hi pot haver entre zero i cinc enters
- **Quina seria una especificació d’atributs de la classe TipusProducte?**
    
    ![58_12_Especificación_Atributos_Clase_TipusProducte.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Imágenes/58_12_Especificación_Atributos_Clase_TipusProducte.png)
    
- **Què vol dir que una aproximació és pura?**
    
    - tot element dins un programa és sempre un objecte, incloent-hi els atributs de cada objecte.
    - Aquesta via és simplement una aplicació estricta de les bases de l’orientació a objectes, que indiquen que tot és un objecte i que un objecte es pot compondre d’altres objectes més simples.
    - Es considera que les classes `Enter`, `Real`, `Caràcter`, etc. existeixen. No cal preocupar-se de com s’emmagatzemen realment els valors que representen; simplement, són capaços de fer la seva feina.
- **Què vol dir que una aproximació és híbrida?**
    
    - Es considera acceptable especificar atributs usant tant objectes com tipus simples indistintament.
    - D’aquesta manera, es té el millor dels dos mons.
    - Normalment, s’usen tipus simples per als atributs més senzills, els que són directament valors, i objectes per als que representen elements més complexos (com és el cas d’una cadena de text, per exemple).
- **Quin tipus d’aproximació usa Java?**
    
    - l’aproximació híbrida.

ENLLAÇOS ENTRE OBJECTES

- **Per què són tan importants els enllaços entre objectes?**
    
    - perquè un objecte només pot cridar l’operació d’un altre objecte si existeix aquest enllaç.
- **Què indica cada enllaç entre objectes?**
    
    - indica, implícitament, un atribut a la classe de l’objecte origen a la classe de l’objecte destinació.
- **Què fem si un objecte ha de gestionar un únic enllaç?**
    
    - usem un únic atribut que serà un objecte de una altra classe
- **Què fem si un objecte ha de gestionar molts enllaços?**
    
    - usarem una llista (List) com a atribut de l’objecte
    
    ```java
    List<Pagina>
    ```
    
- **Com fariem l’atribut d’un objecte agenda que gestiona molts objectes pàgina?**
    
    - usarem una llista (List) com a atribut de l’objecte agenda
    
    ```java
    List<Pagina>
    ```
    

ATRIBUTS DE CLASSE

- **Com es defineixen els atributs de classe?**
    
    - es diferencien subratllant-los
    
    ```java
    __visibilitat nomAtributClasse: tipus [= valor inicial]__
    
    //per exemple:
    __+pi: real__
    ```
    
- **Quina és la particularitat dels atributs de classe?**
    
    - descriuen una propietat de la classe, no dels seus objectes, i el seu valor és únic dins el programa.
    - No hi ha una variable separada dins de cada instància, com passa amb la resta d’atributs.
    - Es pot considerar que un atribut de classe actua com una variable global, compartida per totes les instàncies.

## 1.3.2. ESPECIFICACIÓ D’OPERACIONS

- **Com s’implementen les operacions definides en cada classe?**
    
    - mitjançant mètodes
- **Què conté cada mètode?**
    
    - conté el conjunt d’instruccions del llenguatge de programació necessàries per efectuar la tasca associada
- **Què succeeix quan en un programa en execució un objecte crida una operació?**
    
    - s’executa el codi del mètode associat
- **Què fan les operacions o mètodes accessors?**
    
    - donen accés de lectura o escriptura als atributs d’una classe
- **Quina és la nomenclatura estàndard per a l’accessor d’escriptura (per modificar el valor de l’atribut)?**
    
    - setNomAtribut (valor: tipus)
- **Quina és la nomenclatura estàndard per a l’accessor de lectura (per consultar l’atribut)?**
    
    - getNomAtribut(): tipus
- **Quins són els mètodes que no cal explicitar en l’especificació d’una classe?**
    
    - els mètodes accessors (getters i setters)
- **Com seria una representació gràfica per una classe anomenada Lector?**
    
    ![58_13_Especificación_Operaciones_Clase_Lector.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_13_Especificaci%C3%B3n_Operaciones_Clase_Lector.png)
    

ACCESSIBILITAT DE DADES DINS D’OPERACIONS

- **Quan es converteix una operació en codi?**
    - quan arriba el moment d’implementar-la
- Si es fa una operació cridada sobre un objecte a:ClasseA , a quins valors tindrà accés dire
    - als valors emmagatzemats en els atributs de l’objecte a:ClasseA
    - als valors dels paràmetres de l’operació
- **Si es fa una operació cridada sobre un objecte a:ClasseA , on un valor és un objecte b:ClasseB, a quins valors tindrà accés directe aquesta operació?**
    - als valors emmagatzemats en els atributs de l’objecte a:ClasseA
    - als valors dels paràmetres de l’operació
    - als valors dels atributs amb visibilitat pública de l’objecte b:ClasseB
    - als mètodes amb visibilitat pública de l’objecte b:ClasseB

UBICACIÓ D’OPERACIONS

- **Què vol dir mantenir la cohesió en un disseny orientat a objectes?**
    - obtenir al final del disseny classes amb una certa coherència
    - obtenir al final del disseny classes que aportin una idea molt clara de quin és el seu paper dins el problema que s’està descomponent
- **Què no volem quan dissenyem diferents classes?**
    - no volem crear un conjunt de calaixos de sastre on s’amunteguin atributs i operacions sense cap mena de lògica.
- **Què és molt important quan dissenyem diferents classes?**
    - Les diferents classes del disseny han de coexistir en harmonia i cadascuna ha de tenir un objectiu molt clar.
    - Cumpleixin amb l’objectiu pel qual s’han creat les classes i tinguin un comportament lògic
- **Com aconseguim que hi hagi cohesió en un disseny orientat a objectes?**
    - cada classe ha de representar un únic element, perfectament definit, dins la descomposició del problema.
- **Què és l’assignació de responsabilitats a les classes?**
    - A partir de cada classe s’instancien objectes que actuen com a peces dins la simulació i cadascuna d’aquestes peces té una tasca molt concreta.
    - Només cal assignar els atributs i les operacions mínims imprescindibles per fer aquesta tasca exclusivament.
- **EXEMPLE: si tenim una aplicació d’una agenda, composada per les classes Agenda, Pàgina i Cita, i volem especificar el mètode +afegirCita(c: Cita), en quina classe la hubicarem?**
    - Aplicant el principi de cohesió, aquest mètode haurà d’estar a la classe que gestiona o conté directament les cites. En aquest cas, seria la classe Pàgina.

ESTRATÈGiA PER UBICAR MÈTODES EN LES CLASSES

1.  Localitzar les classes les instàncies de les quals interactuaran (rebran ordres o intercanviaran informació) directament amb l’usuari.
    1.  Normalment, si s’ha seguit l’estratègia d’especificar una classe que representa “el tot”, de manera que el problema es va descomponent a partir d’ella, aquesta sol ser la classe a escollir.
2.  Elaborar una llista d’interaccions possibles amb l’usuari: què és el que realment vol fer l’aplicació.
    1.  Novament, en cap moment s’ha de pensar en una interfície d’usuari concreta. Cal pensar en el *què* però no en el *com*.
3.  Cada element de la llista és una operació que cal especificar a les classes identificades al pas 1.
4.  Per a cada operació, pensar de quina manera cal que els objectes del programa interactuïn per dur-la a terme, i anar especificant noves operacions a la resta de classes.

## 1.3.3. EXEMPLES D’ESPECIFICACIONS D’ATRIBUTS I OPERACIONS

- **Com podem identificar els mètodes que necessita la nostra aplicació?**
    - cal pensar què es vol obtenir amb l’aplicació i quina mena d’operacions han d’anar cridant els diferents objectes per arribar a fer cada tasca.

## EXEMPLE: AGENDA

![58_14_Ejemplo_Agenda.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_14_Ejemplo_Agenda.png)

- A partir de l’objecte *`agenda:Agenda`*, es passaria de pàgina fins arribar a la que correspon a la data escollida, usant les operacions `avançarPàgina` i `retrocedirPàgina`.
    - Aquesta acció la faria l’usuari: és ell qui cridarà aquesta operació. Com ho faci ja depèn de la interfície i del llenguatge emprat. En l’etapa de disseny, aquest fet no importa, n’hi ha prou de saber que ja hi haurà algun mecanisme.
- Cada cop que es passa de pàgina, es pot veure quina és la pàgina actual amb l’operació `llegirPàgina`.
    - Un cop s’obté l’objecte de la pàgina actual, se’n pot inspeccionar el contingut mitjançant les operacions accessores de la classe Pàgina (no especificades explícitament, però existents).
- Per a cada pàgina, es poden visualitzar totes les cites existents amb l’operació `llistarCites`.
- Si aquesta és la pàgina en què es vol afegir una cita, cal instanciar un objecte *`novaCita:Cita`*, inicialitzant tots els seus atributs al valor que correspongui.
    - Novament, com s’instancia un objecte ja és un detall d’implementació, que dependrà del llenguatge escollit; en l’etapa de disseny no cal entrar en aquests detalls.
- Finalment, cal escriure la cita cridant sobre l’objecte de la pàgina actual l’operació `afegirCita(novaCita)`. Evidentment, aquesta operació ha de controlar que no hi hagi encavalcaments d’hora entre les cites escrites en la pàgina.

## EXEMPLE: REPRODUCTOR MULTIMÈDIA

![58_15_Ejemplo_Reproductor_Multimedia.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_15_Ejemplo_Reproductor_Multimedia.png)

- En aquesta especificació es pot apreciar que hi ha operacions repetides. Per entendre els motius d’aquesta circumstància, el més senzill és fer un símil amb un aparell reproductor del món real. D’una banda, l’usuari de l’aparell no interactua mai directament amb tots els components interns, només ho fa amb el tauler de control. Això, en aquest cas, és en contrast amb l’agenda, en què un usuari sí que pot interactuar directament amb les pàgines individuals. Per tant, aquest objecte que representa el tauler de control és el punt d’entrada de les ordres de l’usuari.
- D’altra banda, quan l’usuari dóna una ordre (en el món real, per exemple, prem el botó d’aturada), l’ordre es propaga del tauler de control als components interns (per exemple, un senyal elèctric o una molla fa aturar el lector). Per tant, tot i que el tauler de control i el lector poden rebre una ordre d’aturar, l’acció que faran serà diferent. Mentre que el primer passa l’ordre i informa l’usuari del resultat, el segon atura el processament de la música en marxa i deixa d’enviar senyals als altaveus.
- En aquesta especificació, tot aquest símil es tradueix en forma d’objectes i crides d’operacions. Per tant, en aquesta especificació la instància de la classe Control fa de gestor de totes les peticions de l’usuari cap a la resta de components del reproductor.

## EXEMPLE: APLICACIÓ DE GESTIÓ

![58_16_Aplicación_Gestión.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_16_Ejemplo_Aplicaci%C3%B3n_Gesti%C3%B3n.png)

## 1.4. MANIPULACIÓ D’OBJECTES

- **En què es basa un programa orientat a objectes?**
    - es basa totalment en la gestió i manipulació dels objectes que el componen en cada moment
- **Quin és el primer pas per veure com funciona tot el programa?**
    - saber què es pot fer amb un objecte
- **Què cal fer per poder manipular un objecte?**
    - crear-lo dins el programa
- **Quan podem invocar operacions sobre un objecte?**
    - un cop creat l’objecte en l’aplicació
- **Què cal per tal que un objecte manipuli un altre objecte?**
    - l’objecte que manipula ha de disposar d’un enllaç a l’objecte manipulat
- **Què ens cal per poder treballar amb objectes?**
    - ens cal saber el següent:
        - com crear-los
        - com accedir-hi (o referenciar-los)
        - com inicialitzar-los, com manipular-los
        - com eliminar-los

## 1.4.1. COM ES CREEN ELS OBJECTES?

- **Quin mètode és el que s’encarrega de crear un objecte?**
    
    - el mètode constructor
- **Com distingim el mètode constructor en una classe?**
    
    - perquè té el mateix nom que la classe, incloent majúscules / minúscules
- **Què proporciona que els constructors poden incorporar paràmetres?**
    
    - que hi pugui haver diferents constructors, que es distingeixen pel nombre i/o els tipus dels seus paràmetres.
- **Què cal fer per crear un objecte d’una classe?**
    
    - haurem de consultar la documentació de Java, per saber com són els constructors.
- ## **Com podem crear un objecte Date en Java?**
    
    ```
    new Date (109,0,1);// Objecte amb 1-1-2009 a les 00:00:00
    new Date (0);// Objecte amb 1-1-1970 a les 00:00:00
    ```
    
- **Què fa l’operador new?**
    
    - crea un objecte assignant la memòria necessària de manera automàtica.

## 1.4.2. COM ES FA REFERÈNCIA ALS OBJECTES?

- **Com s’accedeix a l’objecte una vegada creat?**
    - Necessitem algun mecanisme per referir-nos-hi i això s’aconsegueix declarant una variable per fer referència a objectes de la classe concreta i assignant a aquesta variable el resultat de l’execució de l’operador `new`, el qual retorna una referència (adreça de memòria) a l’objecte creat.
- **Com és la sintaxi per declarar un objecte?**
    - primer el tipus (en aquest cas, el nom de la classe) i tot seguit un identificador
- **Què hem d’assignar a obj per tal que faci referència a un objecte?**
    - el resultat de l’execució de l’operador new o assignar-hi el contingut d’una altra variable que estigui fent referència a un objecte de la classe

```
// Declaració de variable de referència no inicialitzada
X obj1;      

// Creació d'objecte al que es podrà accedir via la variable de 
// referència obj1
obj1 = new X(...);  

// Declaració de variable de referència i creació d'objecte al  
// que es podrà accedir via la variable de referència obj2
X obj2 = new X(...); 

// Declaració de variable de referència no inicialitzada
X obj3;

// La variable obj3 fa referència al mateix objecte que fa       
// referència la variable obj1
obj3 = obj1;    

// Declaració de variable de referència que fa referència al 
// mateix objecte que fa referència la variable obj2
X obj4 = obj2;
```

## 1.4.3. COM S’INICIALITZEN ELS OBJECTES?

```
Date d1 = new Date (109,0,1); //Objecte inicialitzat amb data 1-1-2009 a les 00:00:00
Date d2 = new Date (0);   //Objecte inicialitzat amb data 1-1-1970 a les 00:00:00
Date d3 = new Date ();   //Objecte inicialitzat amb la data i l'hora del sistema
```

## 1.4.4. COM ES MANIPULEN ELS OBJECTES?

```
<variableQueFaReferènciaObjecte>.<nomMètode>(<paràmetres>);
```

```
Date d = new Date (109,0,1); // Nou objecte amb valor 1-1-2009
d.setYear (100);      // Canviem valor a 1-1-2000
d.setMonth (5);      // Canviem valor a 1-6-2000
d.setDate (40);      // Canviem valor a 10-7-2000
```

- **Quina és la manera lògica de manipular els objectes d’una classe?**
    - utilitzar les operacions que la classe proporciona i, en la majoria de casos, aquesta serà l’única possibilitat, ja que els dissenyadors de les classes acostumen a obligar a la seva utilització i no permeten l’accés directe a les dades contingudes en els objectes.

## 1.4.5. COM ES DESTRUEIXEN ELS OBJECTES?

- **Per què cal destruir els objectes quan ja no es necessitin?**
    
    - perquè ocupen un espai de la memòria
- **Per què Java ens estalvia feina en l’esborrament dels objectes ?**
    
    - ens permet crear tants objectes com es vulgui (únicament limitats per la pròpia capacitat de memòria del sistema), els quals mai han de ser destruïts, ja que és l’entorn d’execució de Java el que elimina els objectes quan determina que no s’utilitzaran més.
- **Què és el garbage collector (recuperador de memòria)?**
    
    - és un procés automàtic de la màquina virtual Java que periòdicament s’encarrega de recollir els objectes que ja no es necessiten i els destrueix tot alliberant la memòria que ocupaven.
- **Quin mecanisme segueix el recuperador de memòria per detectar els objectes que ja no s’utilitzaran més?**
    
    - escaneja tots els objectes i totes les variables de referències a objectes que hi ha en la memòria de manera que els objectes pels quals no hi ha cap variable de referència que hi apunti són objectes que ja no s’utilitzaran més i, per tant, són recol·lectats per ser destruïts.
- **En quins casos les referències a objectes es perden?**
    
    - Quan la variable que conté la referència deixa d’existir perquè el flux d’execució del programa abandona definitivament l’àmbit en què havia estat creada.
    - Quan la variable que conté la referència passa a contenir la referència en un altre objecte o passa a valer null.
- **Quan s’executa el recuperador de memòria?**
    
    - s’executa automàticament
    - quan un objecte no té cap variable de referència que hi apunti es destrueix
- ## **Com podem fer que el recuperador de memòria s’executi inmediatament?**
    
    ```
    System.gc()
    ```
    
- **Com podem fer que l’objecte faci unes accions abans de ser eliminat?**
    
    - accions que es troben dins del mètode finalize() a la classe de l’objecte
    
    ```
    finalize()
    ```
    
- **En quins casos poden ser necessàries unes accions abans que l’objecte es destrueixi?**
    
    - Quan calgui alliberar recursos del sistema gestionats per l’objecte que és a punt de desaparèixer (arxius oberts, connexions amb bases de dades…).
    - Quan calgui alliberar referències a altres objectes per fer-los candidats a ser tractats pel recuperador de memòria.

## Descomposició d'un partit de futbol

L’objectiu d’aquesta activitat és entendre com funciona la descomposició de problemes seguint l’orientació a objectes.

Relacioneu les preguntes següents, relatives al procés de descomposició en objectes d’un partit de futbol de primera divisió, amb les respostes correctes.

- Quants objectes jugador hi ha?
    
    - jugador
    - pilota
    - porteria
    - camp
    - àrbitre
    - defensa
    - porter
    - Sempre hi haurà 22 més els suplents.
    
- Pot variar el nombre d’objectes jugador?
    
    - Normalment no, excepte casos especials com lesionats que abandonen el camp.
    
- Té sentit que hi hagi objectes arbitre:?
    
    - No hi ha motiu perquè no, ja que són elements clarament importants i identificables, i no es poden considerar jugadors. Com hi ha més d'un àrbitre, poden haver-hi diversos.
    
- Té sentit que hi hagi les classes Defensa o Porter?
    
    - No seria una bona elecció , ja que donat un jugador, aquest pot jugar en qualsevol ubicació (algú que normalment juga de defensa pot acabar jugant de porter). Si aquestes classes existeixen, mai es pot donar aquest cas, ja que els objectes no poden canvair de classe (un objecte de la classe Defensa no pot convertir-se en un de la classe Porter.) És millor si la posició és un atribut d'una classe Jugador.
    
- Té sentit que el número de la samarreta sigui un atribut de jugador?
    
    - Absolutamnet, ja que especifica una propietat del jugador en el joc.
    
- I si dos jugadors es poden canviar la samarreta entre ells?
    
    - També, simplement canvien els valors dels respectius atributs, però els jugadors segueixen tenint un número de samarreta.
    
- Té sentit que un objecte arbitre tingui una operació rebreTargeta?
    
    - No, els arbitres no poden rebre targetes, només els jugadors.   
    

## EL JOC DEL PACMAN

L’objectiu d’aquesta activitat és practicar la descomposició de problemes seguint l’orientació a objectes. Descomposar en objectes una pantalla del joc del [Pacman](http://ca.wikipedia.org/wiki/Pacman). Usar noms descriptius pels objectes.

![58_17_El_Joc_Del_Pacman.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_17_El_Joc_Del_Pacman.png)

## EL JOC DELS VAIXELLS

![58_18_El_Joc_Dels_Vaixells.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_18_El_Joc_Dels_Vaixells.png)

![58_19_El_Joc_Dels_Vaixells.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_19_El_Joc_Dels_Vaixells.png)

## SERVEI DE TRANSPORTS

![58_20_Servei_De_Transports.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_20_Servei_De_Transports.png)

## EL BLACKJACK

![58_21_El_BlackJack.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_21_El_BlackJack.png)

## GESTIÓ DE LA DOCÈNCIA

![58_22_Gestión_De_La_Docencia](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_22_Gesti%C3%B3n_De_La_Docencia.png)

## UN MUD

![58_23_Un_Mud.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_23_Un_Mud.png)

![58_24_Un_Mud.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_24_Un_Mud.png)

![58_25_Un_Mud.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_25_Un_Mud.png)

## IMPLICACIONS DE LES DECISIONS DE DISSENY

![58_26_Implicacions_Decisions_Disseny.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/58_26_Implicacions_Decisions_Disseny.png)

## EXERCICIS

La definició de les classes es realitza durant… la descomposició del problema.

La invocació de mètodes entre objectes es realitza durant… l’execució del programa.

La instanciació dels objectes es realitza durant… l’execució del programa.

L’especificació dels atributs d’una classe es realitza durant… la descomposició del problema.

Una classe…

- sempre defineix el valor dels seus atributs. → FALS
- defineix el comportament de les seves instàncies. → CERT
- és equivalent a un objecte. → FALS
- correspon a cadascun dels elements específics en els que es descomposa el problema. → FALS

Els objectes…

- són els elements en què es descomposa un problema. → VERDADER
- s’especifiquen per poder instanciar classes. → FALS
- invoquen operacions sobre altres classes. → FALS
- diferents d’una mateixa classe no poden tenir valors d’atributs iguals. → FALS
- d’una mateixa classe tenen exactament els mateixos atributs. → VERDADER
- poden canviar de classe. → FALS

Identifiqueu qui fa cada tasca dins de l’orientació a objectes:

- Crea les mètodes → Programador
- Identifica les operacions → Dissenyador
- Identifica les classes → Dissenyador
- Invoca els mètodes → Codi font del programa
- Instancia els objectes → Codi font del programa
- Codifica les classes → Programador