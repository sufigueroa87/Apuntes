# 65\. Aplicaciones con BD no orientadas a objetos

# Resumen

- **De qué dependerá el método de persistencia que podremos usar en nuestro proyecto?**
    - Del tipo de aplicación que tenemos entre manos.
- **Solo podemos tener un método de persistencia en cada proyecto?**
    - No, pueden haber más de un método de persistencia por proyecto.
- **Si almacenamos vídeos en YouTube, cuál sería el método de persistencia que estamos usando?**
    - YouTube.
- **Si los mismos vídeos que almacenamos en YouTube los almacenamos en una base de datos relacional, cuál sería el método de persistencia que estamos usando?**
    - En el método de persistencia YouTube y en el método de persistencia base de datos relacional.
- **Cuál es la manera usual de almacenar datos que:**
    - \*\*estratifican la información (cuando, donde, quién, como...) + \*\*
    - **tienen que proporcionar un estado de los elementos (cantidades, importes, datos, códigos, ...)?**
        - La manera más usual es mediante base de datos relacionales.
- **Qué lenguaje es el más común para interactuar con los datos almacenados desde nuestro programa y hacia nuestro programa?**
    - El lenguaje SQL.
- **Qué base de datos relacional usaremos?**
    - Apache Derby, aunque podríamos usar cualquier otra base de datos relacional con un driver para Java.

* * *

# 2\. Aplicaciones con BD no orientadas a objetos

- **Qué es una base de datos (BD)?**
    - Es un mecanismo para almacenar información de manera que sea sencillo y eficiente recuperar la información.
- **Qué forma toma la base de datos relacional?**
    - Un conjunto de tablas formadas por filas y columnas.
- **De qué depende la manera en que se almacena y se accede a la información de la base de datos?**
    - Del sistema gestor de base de datos, o SGBD (database management system, o DBMS).
- **Qué tiene de particular el sistema gestor de base de datos o SGBD?**
    - Que se encarga de resolver todos los aspectos vinculados a la integridad como , por ejemplo, que no se repitan claves primarias, o el acceso concurrente de los datos.
- **De qué dependen las capacidades de cada SGBD y como funcionan internamente?**
    - Dependen de cada fabricante.

* * *

## 2.1. Traducción del Modelo a una Base de Datos relacional

- **Qué implica que una Base de Datos estructure la información en forma de tablas?**
    - Implica un proceso de transformación des de la manera en que los objetos se estructuran en memoria (el Modelo) a cómo se organizan en una Base de Datos.
- **Cómo se organizan los datos en una Base de Datos?**
    - Cada clase instanciable del Modelo se materializa en la Base de Datos.
    - Cada atributo definido en una clase se materializa en la Base de Datos como una columna dentro de su tabla.
    - La persistencia de cada objeto del Modelo se materializa en la Base de Datos en una fila dentro de la tabla que corresponde a su clase.
    - En cada celda de la tabla se almacena el valor que cada objeto en concreto tiene asignado al atributo.
- **Ejemplo de traducción de una clase a tabla de una Base de Datos. Cada fila corresponde a la persistencia de 3 instancias diferentes de la clase Cliente:**

![65_00_Traduccion_Clase_a_Tabla_Base_Datos.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/65_00_Traduccion_Clase_a_Tabla_Base_Datos.png)

- **Cuántas tablas hay en la base de datos?**
    - Tantas como objetos queremos almacenar.
- **Qué sucede cuando se traspasa un modelo orientado a objetos a tablas dentro de una Base de Datos?**
    - Desaparece su referencia.
- **Cómo podemos recuperar un objeto almacenado en una tabla de una Base de Datos?**
    - Buscaremos en la tabla correspondiente para obtener los valores de los atributos del objeto en cuestión, por si necesitamos instanciar dicho objeto.
- **Qué es muy importante para buscar un objeto concreto en una tabla?**
    - Siempre tiene que haber algún atributo que sea único para cada instancia (para cada objeto), de manera que no haya ambigüedad.
- **Cómo se llama la columna que almacena el atributo que es único para cada objeto de dentro de una tabla?**
    - La columna se llama clave primaria de la tabla.
- **Por qué es tan necesario que exista la clave primaria?**
    - Porque cuando usamos tablas para almacenar objetos, estos dejan de tener referencias que los identifican de manera única y mediante las cuales se pueda acceder al objeto.
    - El identificador único que añadimos al objeto nos ayuda a que haga el mismo servicio que una referencia cuando el Modelo se encuentra en la memoria.
- **Qué tipo de identificador único se suele elegir para los distintos objetos de una tabla?**
    - Se suele elegir un identificador de tipo entero, ya que ocupa poco espacio y es fácil de comparar.
- **Cómo podemos asociar un objeto de una tabla con un objeto de otra tabla?**
    - Cómo se realiza la asociación entre tablas depende de la cardinalidad. Pero básicamente el identificador del objeto debería estar también en la tabla con la que queremos crear asociación. A la clave primaria que se encuentra ahora también en la tabla con la que queremos crear asociación, se le denomina clave foránea.
- **Ejemplo de asociación entre tablas, con cardinalidad 1 o 0...1:**

![65_01_Asociacion_Entre_Tablas.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/65_01_Asociacion_Entre_Tablas.png)

- **Mirando el ejemplo anterior, si queremos enumerar los encargos de un cliente determinado, qué necesitaríamos saber?**
    - El identificador del cliente.
    - Listaríamos todas las filas de la tabla ENCARRECS que tienen como IDCLIENT el identificador del cliente en cuestión.
- **Ejemplo de asociación entre tablas, con cardinalidad 1... * o * :**

![65_02_Asociacion_Tablas_Uno_Muchos.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/65_02_Asociacion_Tablas_Uno_Muchos.png)

* * *

## 2.2. El lenguaje SQL

- **Qué lenguaje genérico permite efectuar las acciones más básicas con una Base de Datos?**
    - El lenguaje SQL.
- **Qué es el lenguaje SQL (structured query language, lenguaje de consultas estructuradas)?**
    - Es un lenguaje estándar para el acceso a Bases de Datos relacionales, de manera que es posible realizar operaciones tales como:
        - Consultar los datos almacenados.
        - Modificar los datos almacenados.
        - etc.
- **Qué es una sentencia SQL?**
    - Es una cadena de texto, con una sintaxis concreta, que indica un conjunto de órdenes a la Base de Datos.
- **En qué 2 tipos podemos dividir las operaciones que permite SQL?**
    - A) Operaciones que componen el lenguaje de definición de datos (data definition language, o DDL):
        - Operaciones que sirven para añadir información a la Base de Datos, principalmente para gestionar tablas.
    - B) Operaciones que forman parte del lenguaje de manipulación de datos (data manipulation language, o DML):
        - Permiten leer o modificar el contenido de la Base de Datos.

* * *

### 2.2.1. Tipos de datos

- **Qué necesitamos hacer antes de poder crear ninguna tabla?**
    - Decidir qué tipo de datos contendrá la tabla en cada una de sus celdas.
    - Decidir los tipos de datos de los atributos de las clases.
- **Tipos de datos SQL:**

![65_03_Tipos_Datos_SQL](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/65_03_Tipos_Datos_SQL.jpg)

* * *

## 2.3. JDBC

- **Qué API proporciona Java como mecanismo para poder generar e invocar sentencias SQL sobre una Base de Datos relacional mediante código en programas Java?**
    - Java Database Connectivity
- **Qué particularidad tiene la API Java Database Connectivity?**
    - Ofrece una interfaz común para el acceso a cualquier tipo de Base de Datos, independientemente del fabricante.
- **El desarrollador tiene que hacer configuraciones en la máquina dónde se ejecuta la aplicación que accede a los datos?**
    - No.
- **Donde se encuentra la biblioteca para usar la API Java Database Connectivity?**
    - En los packages:
        - java.sql
        - javax.sql
- **Qué 5 pasos necesitamos hacer dentro de la aplicación para poder acceder a una Base de Datos desde el código de un programa Java?**
    - 1r paso:
        - Importar correctamente los packages correspondientes.
    - 2o paso:
        - Cargar el controlador (driver) para el acceso a la Base de Datos. Este depende de la Base de Datps a acceder.
    - 3r paso:
        - Establecer la conexión a la Base de Datos.
    - 4o paso:
        - A partir de aquí, ya se pueden ejecutar sentencias SQL en la Base de Datos y procesar las respuestas.
    - 5o paso:
        - Cuando ya no se quiera trabajar más con la Base de Datos, será necesario cerrar la conexión.
- **Ejemplo de código que:**
    - **Consulta todos los clientes de una Base de Datos.**
    - **Muestra el nombre de los clientes consultados.**
    - **Muestra la dirección postal de los clientes consultados.**
    - **En este caso, todas las clases implicadas en el acceso a una Base de Datos pertenecen al package java.sql:**

```Java
    //Importar classes
    import java.sql.*;
    ...                          
     
    //Carregar el controlador per la BD Apache Derby
    Class.forName("org.apache.derby.jdbc.ClientDriver");
     
    //Establir la connexió
    String urlBaseDades = "jdbc:derby://localhost:1527/GestioEncarrecs";
    String usuari = "administrador";
    String contrasenya = "pswdificil";
    Connection c = DriverManager.getConnection(urlBaseDades , usuari, contrasenya);
     
    //Enviar una sentència SQL per recuperar els clients
    Statement cerca = c.createStatement();
    ResultSet r = cerca.executeQuery("SELECT * FROM CLIENTS");
    while (r.next()) {
      System.out.println("Nom: " + r.getString("NOM") +  ", Adreça: " + r.getString("APOSTAL"));
    }
     
    //Tancar la connexió
    c.close();
```

* * *

### 2.3.1. Carga del controlador

- **Qué proporciona JDBC para permitir la independencia de la plataforma?**
    - Proporciona un gestor de controladores que gestiona dinámicamente todos los aspectos específicos del acceso a un tipo de Base de Datos concreto.
- **Quién se encarga de transformar todas las llamadas genéricas a los accesos correspondientes de acuerdo a los mecanismos específicos de la Base de Datos con la que se interactúa?**
    - El JDBC.
- **Qué será necesario si queremos acceder desde la misma aplicación a 4 Bases de Datos de distintos tipos?**
    - Serán necesarios 4 controladores diferentes, cada uno específico para el tipo de Base de Datos a la que queremos acceder.
- **Qué forma toman siempre los controladores?**
    - La forma de una clase de Java.
- **Cómo podemos identificar la clase de Java que equivale a los controladores?**
    - La podemos identificar de manera absoluta con el nombre completo del paquete que la contiene y el nombre de la clase en sí.
- **Tenemos nosotros que registrar los controladores?**
    - No, el registro de los controladores se realiza automáticamente cuando se carga la clase en la memoria, cosa que se hace con la llamada:

```Java
Class.forName(nombreControlador)
```

- **Qué tenemos que hacer para cargar el controlador para acceder a una Base de Datos de tipo Apache Derby?**
    - Cargar el controlador con la sentencia:

```Java
Class.forName("org.apache.derby.jdbc.ClientDriver");
```

- **Cómo podemos saber el controlador del SGBD que necesitamos para poder acceder a la Base de Datos con código Java?**
    - Consultando la documentación del programario para descubrir el nombre de la clase que corresponde al controlador y saber como instalarla en el sistema.
- **Qué necesita la clase que equivale al controlador para que se pueda cargar en nuestra aplicación de Java?**
    - Necesita estar incluida en el CLASSPATH para poderla localizar correctamente.
- **Qué instrucción es la única que SI QUE CAMBIA cuando usamos el JDBC (siempre y cuando NO SE USEN extensiones que no son propietarias de SQL)?**
    - La instrucción "Class.forName"
- **Por qué cambia la instrucción "Class.forName"?**
    - Porque es de una manera o de otra, según el tipo concreto de Base de Datos al que queremos acceder.

* * *

### 2.3.2. Establecimiento de la conexión

- **Qué sentencia tenemos que usar para que la aplicación se pueda conectar remotamente a algún servidor que contiene la Base de Datos? (Supongamos que ya se ha cargado correctamente el controlador):**
    - Tenemos que llamar al método getConnection de la clase DriverManager.

```Java
Connection getConnection(String url, String user, String psw) throws SQLException
```

- **A qué corresponde el parámetro url del método getConnection?**
    - Es una cadena de texto con el identificador de la ubicación de la Base de Datos.
- **Cómo podemos conocer el identificador de la ubicación de una Base de Datos?**
    - Normalmente cuando se configura una Base de Datos podemos ver esta información.
- **Qué es un URL (uniform resource locator, localizador uniforme de recurso)?**
    - Es un apuntador a algún recurso o servicio disponible en Internet. Este recurso puede ser tan simple como un fichero, o elementos más complejos como objetos, un servidor web o, claro, una Base de Datos accesible remotamente.
- **Por qué 4 fragmentos está dividida una URL?**
    - 1r fragmento: El protocolo que necesitamos usar para acceder al recurso. O sea, cuál será el formato de los datos que llegarán al servicio, de manera que las pueda interpretar correctamente.
    - 2o fragmento: El nombre de la máquina, o su dirección IP, de manera que se identifica al equipo donde se encuentra disponible el recurso o el servicio.
    - 3r fragmento: El puerto del servicio, un identificador único asignado a todos los servicios que se ejecuten en la máquina, de manera que es posible dirigir peticiones a un servicio concreto dada una máquina.
    - 4o fragmento: Especifica el nombre del recurso propiamente dentro de la máquina.
- **Qué indica la siguiente url? http://ioc.xtec.cat:80/educacio/ioc-estudis**
    - Indica que mediante el protocolo llamado HTTP (el protocolo que usa la web) necesitamos acceder al puerto 80 (donde se suele ejecutar el servidor web) y obtener el recurso "/educacio/ioc-estudis", que es una página web.
- Qué particularidad tiene una URL para acceder a una Base de Datos mediante JDBC?
    - Tiene la particularidad que el protocolo se divide en 2:
        - El protocolo principal, que sería "jdbc".
        - El subprotocolo.
- **Cuál es el subprotocolo para un servicio de Base de Datos Apache Derby?**
    - "derby".
- **Qué partes contiene una URL?**
    - nombre de la máquina + puerto donde se ejecuta el servicio de la Base de Datos + nombre de la Base de Datos concreta a la que queremos acceder:

```Java
jdbc:derby://192.168.2.1:1527/GestioEncarrecs
```

- - - protocolo principal: jdbc
            \- subprotocolo: derby
            \- nombre de la máquina (dirección de la máquina): 192.168.2.1
            \- puerto donde se ejecuta el servicio de la Base de Datos: 1527
            \- nombre de la Base de Datos concreta a la que queremos acceder: gestioEncarrecs
- **Cómo prevenimos que cualquier aplicación ajena pueda leer los datos de la base de datos a la que accedemos con nuestra aplicación?**
    - Disponiendo de un usuario -> "user"
    - Disponiendo de una password -> "psw"
- **Si no hay ningún usuario o contraseña habilitado (cosa poco recomendable) qué pondremos en user y psw?**
    - "" en los dos parámetros.
- **Qué sucede cuando se establece correctamente una conexión a la Base de Datos? Damos por supuesto que:**
    - **La Base de Datos existe.**
    - **El servicio está en funcionamiento y correctamente configurado.**
    - **No hay ningún problema en la red.**
        - Lo que sucede es que se instancia un objeto de la clase Connection, a partir del cual podemos interactuar para llevar a cabo cualquier acción con la Base de Datos.
- **Ejemplo de código para conectarse a la Base de Datos con la URL del ejemplo anterior: jdbc:derby://192.168.2.1:1527/GestioEncarrecs:**

```Java
    String urlBaseDades = "jdbc:derby://localhost:1527/GestioEncarrecs";
    String usuari = "administrador";
    String contrasenya = "pswdificil";
    Connection c = DriverManager.getConnection(urlBaseDades , usuari, contrasenya);
```

* * *

### 2.3.3. Ejecución de sentencias SQL

- **Cómo se suelen efectuar todas las interacciones con la Base de Datos?**
    - Mediante el envío y la ejecución de sentencias SQL y el procesamiento de las respuestas.
- **Qué mecanismo ofrece JDBC para enviar la cadena de texto con la sentencia que queremos invocar en la Base de Datos?**
    - La clase Statement(sentencia).
- **Qué hace JDBC si la cadena de texto con la sentencia que queremos invocar en la Base de Datos consiste en consultar datos?**
    - Procesa la respuesta de al Base de Datos y la presenta dentro del programa como un objeto del tipo ResultSet, del que podemos extraer información asociada a partir de los métodos que proporciona esta clase.
- **Donde se encuentran las clases Statement i ResultSet?**
    - Dentro el package java.sql.

### LA CLASE Statement

- **Cómo se pueden instanciar los objetos de la clase Statement?**
    - Solo se pueden instanciar mediante la llamada al método createStatement, de la clase Connection.

```Java
    Statement createStatement(int tipus, int concurrencia) 
    throws SQLException
```

- **Qué es en realidad la clase Statement de Java?**
    - Es una interfaz.
- **Qué especifican los parámetros de entrada?**
    - Especifican cuáles serán las propiedades de las respuestas de la ejecución de la sentencia, solo para el caso de ejecutar consultas (SELECT).
- **En qué clase encontramos las constantes estáticas definidas que se aceptan como parámetro de entrada para el método createStatment(int tipo, int concurrencia)?**
    - En la clase ResultSet.
- **Algunas de las constantes que se encuentran definidas en la clase ResultSet:**

![65_04_Algunas_Constantes_De_ResultSet.jpg](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/65_04_Algunas_Constantes_De_ResultSet.jpg)

- **Cómo podemos enviar la sentencia a la Base de Datos una vez se ha inicializado correctamente el objeto y ya se dispone de la cadena de texto con la sentencia?**
    - Llamando al método adecuado.
- **Si queremos hacer una consulta de datos (SELECT) qué método usaremos?**
    - executeQuery
- **Si queremos hacer un INSERT, un UPDATE o un DELETE, qué método usaremos?**
    - executeUpdate
- **Qué tienen de especial los métodos executeQuery y executeUpdate para permitir concretar ciertas particularidades de la ejecución de la sentencia?**
    - Que están sobrecargados.
- **Ejemplo de llamada a los métodos executeQuery y executeUpdate más sencilla, usando como parámetro de entrada la cadena de texto con la sentencia SQL a enviar:**

```Java
    ResultSet executeQuery(String sql) throws SQLException
    int executeUpdate(String sql) throws SQLException
```

- **Qué suele devolver el método executeUpdate?**
    - 0 o el número de filas que han estado manipuladas por la sentencia.
- **Ejemplo para consultar todos los clientes que viven en la dirección 3 de una tabla:**

```Java
    Connection c = ...
     
    Statement s = c.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
    String sentencia= "SELECT * FROM CLIENTS WHERE APOSTAL='Adreça3'";
    ResultSet res = c.executeQuery(sentencia);
```

- **Ejemplo para añadir un nuevo cliente a la base de datos:**

```Java
    Connection c = ...
     
    Statement s = c.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
    String sentencia= "INSERT INTO CLIENTS VALUES (5,'Client5', 
                       'Adreça5','e-mail5@domini.com','+34933336677', 3)";
    int res = c.executeUpdate(sentencia);
```

- **Dónde recae la dificultad en la ejecución de la sentencia mediante la clase Statement?**
    - En nuestra habilidad para crear las sentencias SQL sintácticamente y semánticamente correctas.
- **Ejemplo de sentencia SQL donde no hay necesariamente cadenas de texto estáticas definidas dentro del código:**

```Java
    private static int LAST_ID = 0;
     
    private void crearClient(String nom, String ad, String, String ml, String tlf, int nc) 
    throws SQLException {
     
      Connection c = ...
      ...
     
      Statement s = c.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
      LAST_ID++;
      String sentencia= "INSERT INTO CLIENTS VALUES (" + LAST_ID + ",'" +
                        nom + "','" +
                        ad + "','" +
                        ml + "','" + 
                        tlf + "'," + 
                        nc + ")";
      int res = c.executeUpdate(sentencia);
      ...
    }
```

### LA CLASE PreparedStatement

- **Qué podemos hacer mediante la clase Statement?**
    - Se puede ejecutar cualquier sentencia SQL sin límite.
- **Qué permite la clase PreparedStatement?**
    - Permite ejecutar sentencias parametrizadas, de manera que facilita este tipo de comportamiento dentro de un programa.
- **Qué particularidad principal tiene la clase PreparedStatement?**
    - Tiene una eficiencia superior a Statement.
    - En el momento en que se define la clase PreparedStatement, se precompila. De esta manera, ahorra faena a la Base de Datos.
- **En qué casos es preferible usar la clase PreparedStatement?**
    - Para sentencias sencillas que dependen de parámetros muy concretos aportados por el usuario, y que es necesario usar repetidas veces, solo cambiando estos parámetros, a lo largo de la ejecución del programa.
- **Cómo podemos instanciar un objeto de la clase PreparedStatement?**
    - Llamando a un método estático de la clase Connection. Este método tendrá de parámetro de entrada una sentencia SQL parametrizada.
- **Qué tiene de especial la sentencia SQL parametrizada que usaremos como parámetro de entrada para llamar al método de la clase Connection?**
    - El texto de esta sentencia no está completo, sino que se escribe un interrogante ('?') en cada lugar donde se quiere ubicar un parámetro.
- **Ejemplo de instanciar un objeto de la clase PreparedStatement. En este ejemplo, el programa quiere usar la clase PreparedStatement para llevar a cabo la función de buscar los datos de un cliente dado su nombre:**

```Java
    Connection c =...
     
    //Ara el text de la sentència es posa en crear-la, no en executar-la
    String sentencia= "SELECT * FROM CLIENTS WHERE NOM=?";
    PreparedStatement s = c.preparedStatement(sentencia);
```

- **Qué necesitamos hacer antes de ejecutar la sentencia parametrizada del ejemplo anterior? "SELECT * FROM CLIENTS WHERE NOM=?":**
    - Deberemos asignar valores a sus parámetros, uno para cada interrogante dentro de su texto.
- **Cómo organiza internamente los valores de sus parámetros el objeto de tipo PreparedStatement?**
    - Organiza los parámetros ordenándolos con un índice de 1 a N, de manera que el primer '?' es el parámetro 1, el segundo '?' es el parámetro 2...
- **Cómo podemos asignar valores a cada uno de los índices mencionados en la pregunta anterior?**
    - Mediante métodos.
    - Hay un tipo de método para cada tipo de dato.
    - Necesitaremos invocar tantos métodos como parámetros (número de interrogantes) hay en el texto de la sentencia.

```Java
setString(int parameterIndex, String x)

setInt(int parameterIndex, int x)

setDouble(int parameterIndex, double x)

etc.
```

- **Qué es muy importante hacer para que la sentencia parametrizada que introducimos como parámetro de entrada al llamar al método de la clase connection para crear el objeto de PreparedStatement funcione correctamente?**
    - Necesitaremos usar el método adecuado correspondiente al tipo de dato de acuerdo a la definición de la Base de Datos.
- **Si estamos haciendo una búsqueda para un nombre de cliente, qué método deberemos usar para asignar correctamente el parámetro?**
    - setString, ya que la columna NOMBRE es de tipo VARCHAR(una cadena de texto).
- **Qué necesitamos hacer una vez hemos inicializado correctamente al objeto con los parámetros adecuados, de manera que no quede ningún parámetro por asignar?**
    - Podemos ejecutar el objeto usando:
        - executeQuery o
        - executeUpdate
- **Ejemplo de código para preguntar el nombre del cliente:**

```Java
    //Es pregunta el nom a la interfície d'usuari
    String nom = ...
     
    s.setString(1, nom);
    //Si "nom" és "Client1", ara la sentència equival a:
    //"SELECT * FROM CLIENTS WHERE NOM='Client1'"
     
    ResultSet res = s.executeQuery();
```

### LA CLASE ResultSet

- **Qué contiene la instancia de ResultSet devuelta por una llamada al método executeQuery?**
    - Contiene un listado de filas resultante de la consulta a la Base de Datos.
- **Qué contendrá la instancia de ResultSet si la consulta no ha obtenido ningún resultado?**
    - La instancia de ResultSet estará vacía.
- **Alguna vez podrá la instancia de ResultSet devolver una referencia a null?**
    - NUNCA.
- **Qué sucederá si hay un error en la sentencia SQL ejecutada?**
    - Se producirá una excepción.
- **Cómo podemos navegar por el listado de resultados que se encuentra en el objeto de la clase ResultSet?**
    - Mediante el método adecuado de la clase ResultSet. Esta clase contiene los métodos necesarios para navegar por los objetos res.
- **Cómo se produce la navegación por el listado de resultados contenidos en el objeto res?**
    - Siempre se produce fila por fila.
- **De qué depende el modo de acceso a los resultados del objeto res?**
    - Depende de los parámetros emprados para instanciar el objeto de tipo Statement asociado:
        - Unidireccional o
        - Bidireccional
- **De qué dispone el objeto ResultSet para recordarnos en la posición en que nos encontramos?**
    - Dispone de un apuntador interno.
- **Cómo podemos avanzar o recular el apuntador en el listado de resultados del objeto res?**
    - Mediante la invocación de los métodos de la clase ResultSet:
        - next()
        - previous()
- **Cómo se evalúan los métodos next() y previous() de la clase ResultSet?**
    - Por true:
        - Si la nueva posición del apuntador después de desplazarse contiene una fila válida.
    - Por false:
        - Si nos hemos pasado de la lista, tanto por el inicio como por el final.
- **Dónde se encuentra el apuntador en el inicio del todo?**
    - En una posición por delante de la primera fila.
- **Dónde se posiciona el cursor cuando hacemos la primera llamada a next()?**
    - En la primera fila.
- **Qué sucede si intentamos obtener un dato des del ResultSet sin habernos posicionado en alguna fila correcta?**
    - Dará un error.
- **Una vez estamos posicionados en una fila, cómo podemos consultar el valor de las celdas para cada columna definida en la tabla?**
    - Llamando al método getXXX adecuado según el tipo de dato de la columna a consultar, usando como parámetro de entrada el nombre de la misma columna.
- **Ejemplos de métodos para cada tipo de dato:**
    - String getString(String nomColumna)
    - int getInt(String nomColumna)
    - short getShort(String nomColumna)
    - double getDouble (String nomColumna)
    - java.sql.Date getDate(String nomColumna)
    - etc.
- **Qué devolverán los métodos que devuelven objetos (String, Date) si el valor encontrado en la tabla es NULL?**
    - Devolverán una referencia a null.
- **Qué devolverán los métodos que devuelven un tipo primitivo si el valor encontrado en la tabla es NULL?**
    - Devolverán 0 (o false para los booleans).
- **Cómo podemos saber si el valor que hay en la tabla es NULL o es 0 / false, en caso de los métodos que devuelven un tipo primitivo?**
    - Deberemos usar el método auxiliar wasNull(), inmediatamente después de la llamada al método getXXX. De esta manera, el método getXXX nos devolverá si el valor que hay en la tabla es 0 / false o es NULL.
- **Ejemplo para listar por pantalla el listado de nombres de todos los clientes de la Base de Datos.**

```Java
    Connection c = ...
     
    Statement s = c.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
    String sentencia= "SELECT NOM FROM CLIENTS";
    ResultSet res = c.executeQuery(sentencia);
     
    while (res.next() ) {
      String nom = res.getString("NOM");
      if (!res.wasNull())
        System.out.println(nom);
    }
```

- **Ejemplo de guardar los resultados del objeto de tipo ResultSet llamado res en un arrayList:**

```Java
    Connection c = ...
     
    Statement s = c.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
    String sentencia= "SELECT NOM FROM CLIENTS";
    ResultSet res = c.executeQuery(sentencia);
     
    List<String> llistaNoms = new ArrayList<String>();
     
    while (res.next() ) {
      String nom = res.getString("NOM");
      if (!res.wasNull())
        llistaNoms. add(nom);
    }
     
    //A "llistaNoms" tenim tots els noms resultants de la consulta
```

### MODIFICACIONES A LOS DATOS VÍA ResultSet

- **Qué tenemos que hacer para poder modificar el contenido de las filas del objeto res de tipo ResultSet, y en consecuencia modificar también los valores de la tabla?**
    - Necesitaremos definir que el objeto res de tipo ResultSet devuelto sea de lectura - escritura.
    - Esto lo lograremos con el parámetro:
        - ResultSet.CONCUR_UPDATABLE
- **Cómo podemos modificar los valores de una tabla sin usar sentencias SQL? Sería una perspectiva más de orientación de objetos (manipulando instancias):**
    - Definiendo que el objeto res de tipo ResultSet devuelto sea de tipo lectura-escritura, usando el parámetro tipo:
        - ResultSet.CONCUR_UPDATABLE
- **Qué es en realidad un objeto ResultSet?**
    - Es una asociación viva con la Base de Datos, que va obteniendo los datos poco a poco desde la Base de Datos a través de la conexión, a medida que se van consultando las filas de las respuestas.
- **Qué permite que un objeto ResultSet sea una conexión viva con la Base de Datos?**
    - Permite que podamos leer los datos además de poder escribir en la Base de Datos.
- **Cómo podemos hacer que los cambios en la Base de Datos salgan inmediatamente también en el ResultSet sin tener que esperar a hacer otra consulta?**
    - Usando el parámetro de entrada de tipo ResultSet.TYPE\_SCROLL\_SENSITIVE
- **Si queremos modificar un valor de la tabla, en qué fila tendremos que posicionarnos?**
    - En la fila donde se encuentra el valor a modificar.
- **Cómo se denominan los métodos de escritura?**
    - updateXXX, de manera similar a los de lectura.
- **Ejemplos de métodos para hacer modificaciones en una tabla a través del objeto res de la clase ResultSet:**
    - void updateString(String nomColumna, String s)
    - void updateInt(String nomColumna, int i)
    - short updateShort(String nomColumna, short s)
    - double updateDouble(String nomColumna, double d)
    - void updateDate(String nomColumna, java.sql.Date d)
    - ...
- **Si queremos añadir un valor NULL a la base de datos, qué método tendremos que usar?**
    - updateNull(String nomColumna), independientemente del tipo de dato guardado en la columna.
- **Una vez modificado el objeto res de tipo ResultSet, se actualizan solos los valores de la Base de Datos?**
    - No, tenemos que forzar una actualización sobre la Base de Datos.
- **Cómo podemos forzar una actualización sobre la Base de Datos después de haber modificado un objeto res de tipo ResultSet?**
    - Con el método updateRow().
    - Este método solo actualiza la información de la fila donde se encuentra actualmente el cursor y ninguna otra.
- **Ejemplo de código que pasa a mayúsculas los nombres de todos los clientes de la Base de Datos, aprovechando métodos que ofrece Java para manipular cadenas de texto:**
    - **Podemos ver que el segundo parámetro de creación del Statement es ResultSet.CONCUR_UPDATABLE**

```Java
    Connection c = ...
     
    Statement s = c.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
    String sentencia= "SELECT NOM FROM CLIENTS";
    ResultSet res = c.executeQuery(sentencia);
     
    while (res.next() ) {
      String nom = res.getString("NOM");
      String nouNom = nom.toUpperCase();
      res.updateString("NOM", nouNom);
      res.updateRow();
    }
```

- **Qué métodos usamos para añadir filas en la Base de Datos mediante el objeto res de tipo ResultSet?**
    - 1r paso -> moveToInsertRow(): para indicar que la posición actual se considera ahora una fila nueva.
    - 2o paso -> sucesivas llamadas a updateXXX para añadir los datos a cada columna.
    - 3r paso -> finalmente el método insertRow().
- **Qué método usamos para borrar filas en la Base de Datos mediante el objeto res de tipo ResultSet?**
    - Solo necesitaremos invocar el método deleteRow().

* * *

### 2.3.4. Cerrar de la conexión

- **Cómo podemos cerrar la conexión con la Base de Datos?**

```Java
    Connection c = ...
    ...
    c.close();
```

- **Si nos olvidamos de cerrar la conexión, dicha conexión se queda abierta?**
    - No, porque el recolector de memoria de Java eliminará el objeto de tipo Connection cuando se de cuenta que no se usa.

* * *

### 2.3.5. Ejemplo de aplicación JDBC: El gestor de encargos

- **El siguiente ejemplo gestiona información a una Base de Datos.**
- **El programa gestiona objetos de tipo Client de manera que sus datos se encuentran en una Base de Datos a través de la cual se pueden hacer búsquedas o añadir valores.**
- **Se comporta de 3 maneras:**
    - **Client: define qué información contiene un cliente.**
    - **GestorBD: contiene los métodos asociados al acceso a la base de datos.**
    - **GestorEncarrecs: es la clase principal y ofrece la interfaz de usuario (por consola).**

```Java
    //Fitxer Client.java
    public class Client {
      private int id;
      private String nom;
      private String apostal;
      private String aelectronica;
      private String telefon;
     
      public Client(int i, String n, String ap, String ae, String t){
        id = i;
        nom = n;
        apostal = ap;
        aelectronica = ae;
        telefon = t;
      }
     
      public int getId() { return id; }
      public String getNom() { return nom; }
      public String getAPostal() { return apostal; }
      public String getAElectronica() { return aelectronica; }
      public String getTelefon() { return telefon; }
     
      @Override
      public String toString() {
        return id + "\t" + nom + "\t" + apostal + "\t" + aelectronica + "\t" + telefon ;
      }
    }
```

```Java
    import java.util.*;
    import java.sql.*;
     
    //Aquesta classe fa el mecanisme de persistència independent de la GUI.
    public class GestorBD {
      Connection conn;
     
      public GestorBD() throws Exception {
        Class.forName("org.apache.derby.jdbc.ClientDriver");
        conn = DriverManager.getConnection("jdbc:derby://localhost:1527/GestioEncarrecs", "administrador", "pswdificil");
      }
     
      public void tancar() throws Exception {
        conn.close();
      }
     
      public int obtenirNouIDClient() throws Exception {
        //Cercar ID maxim
        Statement cercaMaxId = conn.createStatement();
        ResultSet r = cercaMaxId.executeQuery("SELECT MAX(ID) FROM CLIENTS");
        if (r.next()) return (1 + r.getInt(1));
        else return 1;
      }
     
      public List<Client> cercarClient(String nom) throws Exception {
        Statement cerca = conn.createStatement();
        ResultSet r = cerca.executeQuery("SELECT * FROM CLIENTS WHERE NOM='" + nom +  "'");
        LinkedList<Client> llista = new LinkedList<Client>();
        while (r.next()) {
          llista.add(new Client(r.getInt("ID"),r.getString("NOM"),r.getString("APOSTAL"), r.getString("AELECTRONICA"),r.getString("TELEFON")));
        }
        return llista;
      }
     
      public void afegirClient(Client c) throws Exception {
        Statement update = conn.createStatement();
        String valors = c.getId() + ",'" + c.getNom() + "','" + c.getAPostal() +  "','" + c.getAElectronica() + "','" + c.getTelefon() + "'";
        update.executeUpdate("INSERT INTO CLIENTS VALUES(" + valors + ")");
      }
    }
```

```Java
    //Fitxer GestorEncarrecs.java
     
    import java.io.*;
    import java.util.*;
     
    //Classe Principal
    public class GestorEncarrecs {
     
      GestorBD gestor;
      BufferedReader entrada;
     
      public static void main(String[] args) throws Exception {
        GestorEncarrecs gbd = new GestorEncarrecs();
        gbd.start();
      }
     
      public GestorEncarrecs() throws Exception{
        gestor = new GestorBD();
        entrada = new BufferedReader(new InputStreamReader(System.in));
      }
     
      public void start() throws Exception {
        int opcio;
        while (0 != (opcio = menuPrincipal())) {
          try {
            switch (opcio) {
              case 1:
                cercarClient();
                break;
              case 2:
                afegirClient();
                break;
              default: mostrarDades("Opció incorrecta\n");
            }
          } catch (Exception ex) {
            mostrarDades("S'ha produït un error: " + ex + "\n");
          }
        }
        gestor.tancar();
      }
     
      private int menuPrincipal() throws Exception {
        String menu = "\nQuina acció vols realitzar?\n" + "[1] Cercar client\n"+  "[2] Afegir client\n" +  "[0] Sortir\n" + "Opció>";
        String lin = entrarDades(menu);
        try { int opcio = Integer.parseInt(lin); return opcio; }
        catch (Exception ex) { return -1; }
      }
     
      //Amb els metodes entrarDades i mostrarDades, fem el codi independent
      //de la interficie. Si mai es fan canvis, nomes cal canviar aquests
      //dos metodes.
     
      private String entrarDades(String pregunta) throws IOException {
        mostrarDades(pregunta);
        return entrarDades();
      }
     
      private String entrarDades() throws IOException {
        String linia = entrada.readLine();
        if ("".equals(linia)) return null;
        return linia;
      }
     
      private void mostrarDades(String dades) throws IOException {
        System.out.print(dades);
      }
     
      //Cercar un element d'acord al seu nom
      private void cercarClient() throws Exception {
        String nom = entrarDades("Introdueix el nom del client: "); if (null == nom) return;
        List<Client> llista = gestor.cercarClient(nom);
        Iterator it = llista.iterator();
        mostrarDades("Els clients trobats amb aquest nom son:\n--------------------------------\n");
        while (it.hasNext()) {
          Client c = (Client)it.next();
          mostrarDades(c.toString() + "\n");
        }
      }
     
     //Afegeix un nou client
     public void afegirClient() throws Exception {
        mostrarDades("Introdueix les seguents dades del nou client (deixa en blanc per sortir).\n");
        String nom = entrarDades("Nom: "); if (null == nom) return;
        String apostal = entrarDades("Adreça postal: "); if (null == apostal) return;
        String aelectronica = entrarDades("E-mail: "); if (null == aelectronica) return;
        String telefon = entrarDades("Telefon: "); if (null == telefon) return;
        int id = gestor.obtenirNouIDClient();
        gestor.afegirClient(new Client(id,nom,apostal,aelectronica,telefon));
        mostrarDades("Operació completada satisfactòriament.\n");
      }
    }
```

* * *

## 2.4. Seguridad en el acceso a la Base de Datos

- **Qué aporta la programación segura?**
    - Un cierto nivel de garantía que una aplicación se comportará siempre de la manera esperada y un usuario con malas intenciones no será capaz de comprometer el sistema aprovechando errores en el código.
- **Cuál es uno de los puntos más importantes al desarrollar aplicaciones que accedan a Bases de Datos?**
    - Cuando se ejecutan las sentencias SQL, estas nunca tienen que incluir directamente ningún tipo de dato del usuario.
    - Todas las entradas que queramos hacer deben validarse antes y se debe comprobar que tienen el formato esperado.
- **Qué es la SQL-Injection?**
    - Consiste en usar un trozo de código para manipular y acceder a una base de datos.
    - Un error sería el siguiente código:

```Java
    ...
    String nom = entrarDades("Introdueix el nom del client"); 
    Statement cerca = c.createStatement();
    ResultSet r = cerca.executeQuery(
    "SELECT * FROM CLIENTS WHERE NOM='" + nom +  "'");    
    System.out.println("Els clients trobats son:");
    while (r.next()) {
    ...
```

- - Vemos que la select es:
        \- "SELECT * FROM CLIENTS WHERE NOM= ' "+ nom + " ' ");
        \- Si el usuario introduce la cadena "Client1", la sentencia SQL que se ejecutará será:
        \- SELECT * FROM CLIENTS WHERE NOM = 'Client1';
        \- Y la salida que tendremos a esta sentencia SQL sería por ejemplo:
        \- Client 1    Direccion1    email1@dominio.com
        \- En el código anterior se comete el ENORME ERROR de usar directamente la entrada del usuario para formar una sentencia SQL de consulta (SELECT).
        \- Ahora bien, si imaginamos que el usuario introduce el texto siguiente:
        \- " 'Client1' OR '1'='1' ";
        \- la sentencia SQL que se ejecutaría sería:
        \- SELECT * FROM CLIENTS WHERE NOM = 'Client1' OR '1'='1';
        \- Por lo tanto, como la expresión '1'='1' evalúa si es cierto, lo que estaríamos haciendo con esta sentencia exactamente:
        \- SELECT * FROM CLIENTS;
- **Cómo podemos evitar la SQL-Injection?**
    - 1a manera: El código de nuestros programas tiene que procesar cualquier cadena de texto que depende de una entrada del usuario antes de permitir que forme parte del texto de una sentencia SQL.
    - 2a manera: Usando sentencias parametrizadas, PreparedStatement, ya que son inmunes a este ataque.

* * *

# Ejercicios

- **Qué expresión SQL permite incluir expresiones regulares a su sintaxis?**
    - LIKE
- **Dada la tabla creada de la siguiente manera y las sentencias siguientes:**

```Java
    CREATE TABLE PRODUCTES
    ( ID INTEGER PRIMARY KEY,
      NOM VARCHAR(20) NOT NULL,
      QUANTITAT INTEGER,
      PREU DOUBLE)	
     
    INSERT INTO inventory
    VALUES(1,'Pantalla LCD',20, 129.99)
     
    INSERT INTO inventory
    VALUES(2,'Impressora', 7, 49.99)
     
    INSERT INTO inventory
    VALUES(3, 'Llapis USB', 100 , 4.99)
     
    INSERT INTO inventory
    VALUES(4, 'Altaveus', 15, 7.99)
     
    INSERT INTO inventory
    VALUES(4, 'Portàtil', 10, 299.99)
     
    SELECT NOM
    FROM PRODUCTES
    WHERE PREU > AVG(PREU)
```

- - En total s’han executat vuit sentències SQL. -> FALSE
        \- Al final, a la taula hi ha emmagatzemats tres productes, ja que hi ha alguna sentència INSERT errònia. -> FALSE
        \- Al final, a la taula hi ha emmagatzemats quatre productes, ja que hi ha alguna sentència INSERT errònia. -> TRUE
        \- Al final, hi ha emmagatzemats cinc productes a la taula. -> FALSE
        \- La taula no accepta qualsevol nom de producte. -> TRUE
        \- La consulta final mostra el preu dels productes. -> FALSE
        \- La consulta final mostra el preu mitjà dels productes. -> FALSE
        \- Només un únic producte a la taula compleix la condició de la consulta. -> FALSE
- **Identificar la clase según su descripción:**
    - És el resultat d’executar una consulta usant JDBC… -> ResultSet
    - Encapsula una consulta SQL a JDBC… -> Statement
    - Encapsula una consulta SQL parametritzada a JDBC… -> PreparedStatement
    - Crea una connexió amb la BDD… . -> Connection
    - Gestiona els controladors d’accés a la BDD…. -> DriverManager
    - Informa d’errors en l’accés a la BDD…. -> SQLException
- **Dado el código siguiente, elige la afirmación más adecuada:**

```Java
    Connection c = ...;
     
    String sentencia= "SELECT * FROM CLIENTS WHERE NOM = ? AND NCOMANDES > ?";
    PreparedStatement s = c.createPreparedStatement(sentencia);
     
    String nom = entrarDadesString("Introdueix el nom del client"); 
    int num = entrarDadesInt("Introdueix el nombre de comandes"); 
     
    s.setString(1, nom);
    s.setInt(2, num);
     
    ResultSet r = s.executeQuery();
    ...
```

- - No hay peligro de SQL-Injection, porque se está usando la sentencia parametrizadas PreparedStatement.

* * *

# Ejercicios:

- Ejercicio1:

![65_05_Ejercicio1.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/65_05_Ejercicio1.png)

- **Segurament la taula Sessions era una classe associativa al diagrama UML original. -> VERITAT**
  - La columna **Nom** serveix com a clau primària de la taula **Sales**. -\> FALS
  - **En la taula Activitats hi poden haver files amb el mateix Nom. -> VERITAT**
  - **Donat el nom d’una activitat, es pot obtenir una llista amb totes les sales on es practica. -> VERITAT**
  - **En la taula Sessions, la columna Activitat desa claus foranes. -> VERITAT**
  - No té sentit que existeixi la fila 2 de la taula **Sales**, ja que no s’usa enlloc.  -> FALS
  
***
  
- **Elige la opción correcta:**
  - Quina expressió SQL permet incloure expressions regulars en la seva sintaxi? -> LIKE

***

- **Dada la tabla creada de la manera siguiente y las sentencias SQL siguientes, di si es verdadero o no:**

```Java
    CREATE TABLE PRODUCTES
    ( ID INTEGER PRIMARY KEY,
      NOM VARCHAR(20) NOT NULL,
      QUANTITAT INTEGER,
      PREU DOUBLE)	
     
    INSERT INTO inventory
    VALUES(1,'Pantalla LCD',20, 129.99)
     
    INSERT INTO inventory
    VALUES(2,'Impressora', 7, 49.99)
     
    INSERT INTO inventory
    VALUES(3, 'Llapis USB', 100 , 4.99)
     
    INSERT INTO inventory
    VALUES(4, 'Altaveus', 15, 7.99)
     
    INSERT INTO inventory
    VALUES(4, 'Portàtil', 10, 299.99)
     
    SELECT NOM
    FROM PRODUCTES
    WHERE PREU > AVG(PREU)
```

  - En total s’han executat vuit sentències SQL. -> false
  - Al final, a la taula hi ha emmagatzemats tres productes, ja que hi ha alguna sentència INSERT errònia. -> false
  - **Al final, a la taula hi ha emmagatzemats quatre productes, ja que hi ha alguna sentència INSERT errònia. -> VERITAT**
  - Al final, hi ha emmagatzemats cinc productes a la taula. -> false
  - **La taula no accepta qualsevol nom de producte. -> VERITAT**
  - La consulta final mostra el preu dels productes. -> false
  - La consulta final mostra el preu mitjà dels productes. -> false
  - Només un únic producte a la taula compleix la condició de la consulta. -> false
  
***
  
- **Identifica la clase según su descripción:**
  - És el resultat d’executar una consulta usant JDBC… -> ResultSet
  - Encapsula una consulta SQL a JDBC… -> Statement
  - Encapsula una consulta SQL parametritzada a JDBC… -> PreparedStatement
  - Crea una connexió amb la BDD… . -> Connection
  - Gestiona els controladors d’accés a la BDD…. -> DriverManager
  - Informa d’errors en l’accés a la BDD…. -> SQLException
  
***
  
- **Dado el código Java siguiente, elige la afirmación más adecuada:**

```Java
    Connection c = ...;
     
    String sentencia= "SELECT * FROM CLIENTS WHERE NOM = ? AND NCOMANDES > ?";
    PreparedStatement s = c.createPreparedStatement(sentencia);
     
    String nom = entrarDadesString("Introdueix el nom del client"); 
    int num = entrarDadesInt("Introdueix el nombre de comandes"); 
     
    s.setString(1, nom);
    s.setInt(2, num);
     
    ResultSet r = s.executeQuery();
    ...
```

- Hi ha perill d’SQL-Injection.
  - Si hi ha perill o no d’SQL-Injection depèn totalment de com s’hagi fet el mètode “entrarDadesString”.
  - Si hi ha perill o no d’SQL-Injection depèn totalment de com s’hagi fet el mètode “entrarDadesInt”.
  - **No hi ha perill d’SQL-Injection. -> VERDADERA**
