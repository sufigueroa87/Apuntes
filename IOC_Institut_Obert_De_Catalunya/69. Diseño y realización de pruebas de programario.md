# 69\. Diseño y realización de pruebas de programario

# Resumen

- **Qué aprenderemos en esta unidad?**
    - Herramientas y métodos muy importantes para mejorar el código de programación que se desenvolupa en un proyecto de creación de aplicaciones informáticas.
- **Qué pasos tenemos que hacer para realizar las pruebas del código?**
    - <ins>Descripción del plan de pruebas:</ins>
        
        - Definir el alcance de las pruebas.
        - Definir el tipo de prueba y sus propiedades.
        - Definir los elementos del programario que se quieren probar.
    - <ins>Elementos del programario a probar:</ins>
        
        - Determinar los elementos del programario que se tienen que tener en cuenta en el plan de pruebas, así como las condiciones mínimas que se deben cumplir para llevarlo a cabo.
    - <ins>Elementos del programario que no se tienen que probar:</ins>
        
        - Es importante definir los elementos que no se tienen que tener en cuenta en el plan de pruebas.
    - <ins>Estrategia del plan de pruebas:</ins>
        
        - Definir la técnica a utilizar en el diseño de los casos de prueba, como:
            - La técnica de la caja blanca o caja negra.
        - Definir las herramientas que se utilizarán, incluso el grado de automatización de las pruebas.
    - <ins>Definición de la configuración del plan de pruebas:</ins>
        
        - Definir las circunstancias bajo las cuales el plan de pruebas será alterado, finalizado, suspendido o repetido.
    - <ins>Documentos a entregar:</ins>
        
        - Definir los documentos que necesitamos entregar durante el plan de pruebas y finalizarlo.
    - <ins>Tareas especiales:</ins>
        
        - Definir las tareas necesarias para preparar y ejecutar las pruebas.
    - <ins>Recursos:</ins>
        
        - Para cada tarea definida dentro del plan de pruebas, se tendrá que asignar uno o diversos recursos, que serán los encargados de llevarla a cabo.
    - <ins>Responsables y Responsabilidades:</ins>
        
        - Se define el responsable de cada una de las tareas previstas en el plan.
    - <ins>Calendario del plan de pruebas:</ins>
        
        - En el calendario pueden estar descritas las tareas que se deberán ejecutar, indicando:
            - Sus dependencias.
            - Los responsables.
            - Las fechas de actuación.
            - La duración de la actuación.
            - Las finalidades de las pruebas.
- **6 tipos de pruebas que podemos llevar a cabo en las diferentes fases de un proyecto informático:**
    - Estructurales o de caja blanca.
    - Funcionales o de caja negra.
    - De integración.
    - De carga y aceptación.
    - De sistema y seguridad.
    - De regresión y de humo.

* * *

# 1\. Diseño y realización de pruebas de programario

## 1.1. Introducción

- **Qué puede necesitar un error no detectado al inicio del desarrollo de un proyecto?**
    - Puede necesitar cincuenta veces más esfuerzos para ser solucionado que si es detectado a tiempo.
- **Qué coste se dedica en el desarrollo de un proyecto a la fase de pruebas?**
    - Entre un 30% y un 50%.
- **En qué influirán los resultados de las pruebas?**
    - En la percepción que tendrá el cliente final en relación con el producto (programario) entregado y su calidad.
- **Cuál es el objetivo de las pruebas en el desarrollo de un proyecto?**
    - Evaluar la calidad del programario desarrollado durante todo su ciclo de vida, validando:
        - Que hace lo que tiene que hacer.
        - Que hace lo que tiene que hacer tal y como se diseñó a partir de los requerimientos.

* * *

## 1.2. Las pruebas en el ciclo de vida de un proyecto

- **Qué es necesario hacer en cada una de las fases del ciclo de vida de un proyecto?**
    - Será necesario que el trabajo sea validado y verificado.
- **Esquema de cómo encajan las pruebas en el ciclo de vida en V del programario:**

![69_00_Pruebas_Programario.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/69_00_Pruebas_Programario.png)

- **Qué hay que hacer cuando se detectan errores en un producto?**
    - Se deberá volver a la fase anterior para depurarlo y corregirlo. Esto se indica en las flechas de vuelta de la parte izquierda de la figura.
- **Qué permiten las herramientas CASE?**
    - Ayudan a llevar a cabo los procesos de prueba. Se encargan de depurar errores en los programas.
- **Cómo se conocen las herramientas CASE?**
    - Se conocen como depuradores.
- **Qué cubre el proceso de verificación?**
    - Las fases de diseño e implementación del producto.
- **Qué personas están implicadas en la ejecución del proceso de verificación?**
    - Los desarrolladores + El ingeniero de pruebas.
- **De qué se encargarán los desarrolladores?**
    - Harán pruebas sobre el código.
- **De qué se encargará el ingeniero de pruebas?**
    - Hará pruebas sobre el diseño del sistema.
- **Para qué usaremos el término Validación?**
    - Para evaluar positivamente si el producto desarrollado cumple los requisitos establecidos en el análisis.
- **Quiénes se encargan de hacer las pruebas de validación?**
    - Los ingenieros de pruebas.
- **Finalmente, quién tiene que dar el OK al producto?**
    - El cliente.

* * *

## 1.3. Procedimientos, tipos y casos de prueba

- **Por qué algunos autores consideran que los procedimientos relacionados con las pruebas son como un pequeño proyecto englobado dentro del proyecto de desarrollo?**
    - Porque es necesario dedicar un tiempo considerable a desarrollar las tareas y los procedimientos referidos a las pruebas.
- **Qué requiere el proyecto de pruebas?**
    - Planificación.
    - Diseño del plan de pruebas.
    - Ejecución de las pruebas.
    - Evaluación de los resultados.
- **Qué finalidad tiene el proyecto de pruebas?**
    - Analizar los errores y poder aplicar las acciones necesarias.
- **Esquema de los procedimientos que serán necesarios llevar a cabo + Documentación necesaria a adjuntar:**

![69_01_Procedimientos_Documentacion.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/69_01_Procedimientos_Documentacion.png)

- **Resumen del esquema anterior:**
    - 1\. Iniciamos con la <ins>planificación de las pruebas:</ins>
        - Tiene como punto de partida:
            - El análisis funcional del producto a desarrollar.
            - Los diagramas de casos de uso del producto a desarrollar.
            - ...
        - Se estimarán los recursos necesarios para:
            - La elaboración de las pruebas.
            - La posterior validación del programario.
        - Se obtiene un plan de pruebas como salida.
    - 2\. Del plan de pruebas obtenido en la planificación + El código fuente desarrollado: Se crea el <ins>diseño de las pruebas:</ins>
        - Identificando:
            - Qué tipo de pruebas se realizarán para cada una de las funcionalidades.
        - Obteniendo:
            - Los casos de prueba.
            - Los procedimientos.
    - Una vez creado el diseño de las pruebas, se inicia un bucle donde:
        - 3\. Se <ins>ejecutan las pruebas</ins>.
        - 4\. Se <ins>evalúan los resultados de las pruebas</ins> efectuadas detectando errores.
        - 5\. Se <ins>depura el código</ins> aplicando las correcciones pertinentes.
        - Se vuelven a <ins>ejecutar las pruebas</ins>.
    - 6\. Finalizado el bucle, se hace un <ins>análisis de la estadística de errores</ins>:
        - Permite hacer predicciones de la fiabilidad del programario.
        - Permite detectar las causas más habituales de error.
        - Se podrán mejorar los procesos de desarrollo.

* * *

### 1.3.1. Planificación de las pruebas

- **Cuándo se tiene que realizar la planificación de las pruebas?**
    - La planificación de las pruebas tiene que irse desarrollando a lo largo de todas las fases del proceso informático.
- **Cuándo se tienen suficientes datos como para poder empezar a establecer las primeras líneas del plan de pruebas?**
    - En la fase de análisis y la fase de diseño.
- **⚠️⚠️⚠️ Qué tenemos que tener en cuenta en cuanto a los errores que se pueden dar en el desarrollo del proyecto informático?**
    - Cuánto antes se detecte un error, más sencillo será contrarrestar y solucionar dicho error.
- **⚠️⚠️⚠️ Qué sucede con el coste en relación a la resolución de un problema?**
    - Que el coste crece exponencialmente a medida que avanzan la fases del proyecto en las que se detecte. Por tanto, cuanto antes se detecte el error, menos coste se necesitará para resolverlo.
- **En la realidad, cuándo suelen hacerse las pruebas en el desarrollo de un proyecto?**
    - Al final del proyecto, cosa errónea.
- **⚠️⚠️⚠️ Cuál es el objetivo de la planificación de las pruebas?**
    - Llegar a la creación de un plan de actuación que se refiera a cuándo y cómo se llevarán a cabo las pruebas. Para ello, necesitamos llevar a cabo:
        - un análisis minucioso del sistema.
        - un análisis minucioso de los elementos del sistema.
- **Qué debe contener el plan de pruebas?**
    - Todas las funciones implicadas.
    - Todas las estrategias implicadas.
    - Todas las técnicas implicadas.
    - Todos los miembros del equipo de trabajo implicados.
- **Dónde podemos encontrar una buena guía para determinar qué contendrá un buen plan de pruebas?**
    - En la normativa IEEE 829-2008 "Standard for Software and System Test Documentation".
- **Qué establece el "Standard for Software and System Test Documentation"?**
    - Cómo deberá de ser la documentación.
    - Cómo deberán de ser los procedimientos que se usarán en las diferentes etapas de las pruebas del programario.
- **11 contenidos del plan de pruebas:**
    - <ins>1\. Identificador del plan de pruebas:</ins>
        
        - Identificador que se asignará al plan de pruebas.
        - Muy importante para identificar fácilmente el alcance del plan de pruebas.
    - <ins>2\. Descripción del plan de pruebas:</ins>
        
        - Define:
            - El alcance del plan de pruebas.
            - El tipo de prueba y sus propiedades.
            - Los elementos del programario que se quieren probar.
    - <ins>3\. Elementos del programario a probar:</ins>
        
        - Determina los elementos del programario que se tienen que tener en cuenta en el plan de pruebas.
        - Determina las condiciones mínimas que se tienen que cumplir para llevar a cabo las pruebas.
    - <ins>4\. Elementos del programario que no se tienen que probar.</ins>
        
    - <ins>5\. Estrategia del plan de pruebas:</ins>
        
        - Define la técnica a utilizar en el diseño de los casos de prueba, como por ejemplo:
            - La técnica de la caja blanca.
            - La técnica de la caja negra.
        - Define herramientas que se utilizarán.
        - Define la automatización de las pruebas.
    - <ins>6\. Definición de la configuración del plan de pruebas:</ins>
        
        - Define las circunstancias bajo las cuales el plan de pruebas podrá ser:
            - Alterado.
            - Finalizado.
            - Suspendido.
            - Repetido.
    - <ins>7\. Documentos a entregar:</ins>
        
        - Define los documentos que es necesario entregar:
            - Durante el plan de pruebas.
            - En finalizar el plan de pruebas.
        - La información debe contener:
            - Información referente al éxito de las pruebas ejecutadas con todo detalle.
            - Información referente al fracaso de las pruebas ejecutadas con todo detalle.
    - <ins>8\. Tareas especiales:</ins>
        
        - Define las tareas necesarias para:
            - Preparar las pruebas.
            - Ejecutar las pruebas.
        - Para las tareas que tengan un carácter especial, por su importancia o independencia de las otras, será necesario:
            - Realizar una planificación más detallada.
            - Determinar bajo qué condiciones se llevarán a cabo estas tareas.
    - <ins>9\. Recursos:</ins>
        
        - Para cada tarea definida en el plan de pruebas, se deberá asignar uno o dos recursos, que serán los encargados de llevar a cabo la tarea.
    - <ins>10\. Responsables y Responsabilidades:</ins>
        
        - Se define el responsable de cada una de las tareas previstas en el plan.
    - <ins>11\. Calendario del plan de pruebas:</ins>
        
        - Se describen las tareas que se deberán ejecutar, indicando:
            - Sus dependencias.
            - Los responsables.
            - Las fechas de actuación.
            - La duración.
            - Las metas del plan de pruebas.
        - Una herramienta muy usada para representar este calendario del plan de pruebas es:
            - El Diagrama de Gantt.
- **Qué necesitamos para planificar el plan de pruebas a lo largo de todo el proyecto, en vez de sólo hacerlo de manera puntual?**
    - <ins>Gestionar los cambios:</ins>
        - Será necesario adaptar el plan de pruebas a los cambios que se vayan presentando a lo largo del proyecto.
    - <ins>Gestionar los riesgos.</ins>
- **⚠️⚠️⚠️ Qué es un riesgo?**
    - Conjunto de situaciones que pueden provocar un impedimento o retraso en el plan de pruebas.
- **Cuando es mejor identificar los riesgos y analizar la probabilidad de que sucedan?**
    - Lo antes posible.
    - Se aplicarán medidas preventivas y, si se considera necesario, se dispondrá de un plan de contingencia en caso de que el riesgo se de.

* * *

### 1.3.2. Diseño de las pruebas. Tipos de pruebas.

- **Qué paso es el siguiente después de haber realizado el plan de pruebas?**
    - El diseño de las pruebas.
- **En qué consiste el diseño de las pruebas?**
    - En establecer los casos de prueba, identificando el tipo de prueba que se deberá efectuar.
- **Ejemplos de tipos de prueba:**
    - Estructurales o de caja blanca.
    - Funcionales o de caja negra.
    - De integración.
    - De carga y aceptación.
    - De sistema y de seguridad.
    - De regresión y de humo.

### CASOS DE PRUEBA Y PROCEDIMIENTOS

- **Qué se habrá especificado a partir del plan de pruebas?**
    - Las partes del código a tratar.
    - En qué orden será necesario realizar las pruebas.
    - Quién hará las pruebas.
    - Mucha otra información...
- **⚠️⚠️⚠️ Qué es un caso de prueba?**
    - Define cómo se llevarán a cabo las pruebas, especificando:
        - Los tipos de pruebas.
        - Las entradas de las pruebas.
        - Los resultados esperados.
        - Las condiciones bajo las cuales deben desarrollarse las pruebas.
- **Qué objetivo tienen los casos de prueba?**
    - Identificar los errores que hay en el programario para que estos errores no lleguen al usuario final.
- **Dónde pueden encontrarse los errores?**
    - Como defectos en la interfaz de usuario.
    - Como defectos en la ejecución de estructuras de datos.
    - Como defectos en un determinado requisito funcional.
- **Qué 2 cosas tenemos que validar en el momento de diseñar los casos de prueba?**
    - Hay que validar que la aplicación haga lo que se espera frente las entradas correctas.
    - Hay que validar que la aplicación tenga un comportamiento estable frente entradas no esperadas, informando del error.
- **Qué 2 enfoques tenemos para desarrollar y ejecutar los casos de prueba en un proyecto informático?**
    - <ins>Las pruebas de caja negra:</ins>
        - Su objetivo es validar que el código cumple la funcionalidad definida.
    - <ins>Las pruebas de caja blanca:</ins>
        - Se centran en la implementación de los programas para elegir los casos de prueba...
- **Ejemplo de implementación de un caso de prueba con Java que valida el coste de una matrícula:**

```Java
CONST PREU_CREDIT = 100€
public void CasProva_CostMatricula(){
    try {
        int credits = 0;
        float preu = 0;
        crèdits = CreditsAssignatura ("Sistemes informàtics"); //12 crèdits
        crèdits += CreditsAssignatura ("Programació");         //15 crèdits
        crèdits += CreditsAssigantura ("Accés a dades");       //12 crèdits
    preu = crèdits * PREU_CREDIT;
    assertTrue (preu==00€);
    }catch (Exception e) {Fail ("S’ha produït un error");}
}
```

- **Qué hace el método CasProva_CostMatricula?**
    - Calculará el precio que deberá pagar un alumno por matricularse en diversas asignaturas.
    - La prueba valida que el cálculo de la operación coincida con el resultado esperado, usando la instrucción assertTrue.
- **Qué permiten los casos de prueba?**
    - Permiten validar la aplicación que se está desarrollando, siendo necesario tener a mano:
        - La documentación generada en el análisis funcional
        - La documentación generada en el análisis técnico.
        - La documentación generada en el diseño:
            - Casos de uso.
            - Diagramas de secuencia.
            - ...
- **Las 5 etapas del ciclo de vida de los casos de prueba:**
    - 1\. Definición de los casos de prueba.
    - 2\. Creación de los casos de prueba.
    - 3\. Selección de los valores para los tests.
    - 4\. Ejecución de los casos de prueba.
    - 5\. Comparación de los resultados obtenidos con los resultados esperados.
- **Cómo debe de ser cada caso de prueba?**
    - Tendrá un inicio y un final muy marcado.
    - Deberá almacenar toda la información referente a:
        - Su definición.
        - Su creación.
        - Su ejecución.
        - Su validación final.
- **12 informaciones que debería contener cada caso de prueba:**
    - Identificador del caso de prueba.
    - Módulo o función a probar.
    - Descripción del caso de prueba detallado.
    - Entorno necesario para que se pueda realizar la ejecución del caso de prueba.
    - Datos necesarios para el caso de prueba, especificando sus valores.
    - Tareas que ejecutará el plan de pruebas y su secuencia.
    - Resultado esperado del caso de prueba.
    - Resultado obtenido del caso de prueba.
    - Observaciones o comentarios tras la ejecución.
    - Responsable del caso de prueba.
    - Fecha de ejecución del caso de prueba.
    - Estado del caso de prueba (finalizado, pendiente, en proceso).
- **A qué está asociado, como mínimo, cada caso de prueba?**
    - A un procedimiento de prueba.
- **⚠️⚠️⚠️ Qué son los procedimientos de prueba?**
    - Especifican cómo se podrán llevar a cabo los casos de prueba o parte de los casos de prueba de forma independiente o de forma conjunta, estableciendo:
        - Las relaciones entre los casos de prueba.
        - El orden en qué deberán atenderse los casos de prueba.
- **Esquema de las pruebas, desde la creación del plan de pruebas hasta su ejecución:**

![69_02_Esquema_Casos_Prueba.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/69_02_Esquema_Casos_Prueba.png)

### TIPOS DE PRUEBAS

- **9 tipos de pruebas:**
    
    - <ins>1\. Tipos de pruebas unitarias:</ins>
        
        - Tipos de pruebas de más bajo nivel.
        - Se llevan a cabo a medida que se va desarrollando el proyecto.
        - Las efectúan los propios programadores.
        - Tienen como objetivo la detección de:
            - Errores en los datos.
            - Errores en los algoritmos.
            - Errores en la lógica.
        - Las pruebas unitarias se podrán llevar a cabo según:
            - Un enfoque estructural.
            - Un enfoque funcional.
        - El método usado en este tipo de pruebas es uno de los dos siguientes:
            - El de caja blanca.
            - El de caja negra.
    - <ins>2\. Tipos de pruebas funcionales:</ins>
        
        - Encargadas de detectar los errores en la implementación de los requerimientos de usuario.
        - Las llevan a cabo los verificadores y analistas (personas diferentes a los desarrolladores).
        - Se efectúan durante el desarrollo del proyecto.
        - El tipo de método usado es el funcional.
    - <ins>3\. Tipos de pruebas de integración:</ins>
        
        - Se llevan a cabo posteriormente a las pruebas unitarias.
        - Las efectúan los mismos programadores.
        - Se llevan a cabo durante el desarrollo del proyecto.
        - Se encargan de detectar errores de las interfaces y en las relaciones entre los componentes.
        - El método usado es:
            - El de caja blanca.
            - El del diseño descenciente.
            - El del bottom-up.
    - <ins>4\. Tipos de pruebas de sistemas:</ins>
        
        - La finalidad es detectar errores en lograr los requerimientos.
        - Se llevan a cabo por verificadores y analistas, es decir, personas diferentes a aquellas que han programado el código.
        - Se efectúan en una fase de desarrollo del programario.
        - El tipo de método usado es el funcional.
    - <ins>5\. Tipos de pruebas de carga:</ins>
        
        - Se efectúan una vez acabado el desarrollo, pero antes de las pruebas de aceptación.
        - También las realizan analistas y verificadores.
        - Se comprueba el rendimiento y la integridad de la aplicación ya acabada con datos reales, en un entorno que también simula el entorno real.
        - Se realizan con un enfoque funcional.
    - <ins>6\. Tipos de pruebas de aceptación:</ins>
        
        - Su objetivo es la validación o aceptación de la aplicación por parte de los usuarios.
        - Por eso las llevan a cabo los clientes o los usuarios finales de la aplicación.
        - Son pruebas que se llevan a cabo una vez finalizada la fase de desarrollo.
        - Es posible realizar las pruebas en la fase previa a la finalización y a en la transferencia o en la fase de producción, mientras los usuarios ya usan la aplicación.
        - El tipo de método es el funcional.
        - Incluyen distintos tipos de pruebas. Por ejemplo:
            - Las pruebas alfa: El cliente realiza las pruebas en el entorno del desarrollador.
            - Las pruebas beta: El cliente realiza las pruebas en el propio entorno del cliente.
    - <ins>7\. Tipos de pruebas de sistema:</ins>
        
        - Se realizan después de las pruebas de aceptación y con el sistema ya integrado en el entorno de trabajo.
        - Su finalidad es comprobar que esta integración es correcta.
        - El enfoque usado es el de la caja negra.
        - Estas pruebas las realizan verificadores y analistas.
        - Incluyen distintos tipos de pruebas. Por ejemplo:
            - Pruebas de rendimiento.
            - Pruebas de resistencia.
            - Pruebas de robustez (en cuanto a entradas incorrectas).
            - Pruebas de seguridad.
            - Pruebas de usabilidad.
            - Pruebas de instalación.
    - <ins>8\. Tipos de pruebas de regresión:</ins>
        
        - Su finalidad es detectar posibles errores introducidos al haber realizado cambios en el sistema, ya sea para mejorarlo, o para corregir errores.
        - Consisten en repetir pruebas ya realizadas con éxito antes de realizar el cambio.
        - Incluye tanto pruebas de caja blanca como de caja negra.
    - <ins>9\. Tipos de pruebas "de humo":</ins>
        
        - Son pruebas rápidas de las funciones básicas de un programa que normalmente se realizan después de un cambio en el código antes de registrar este código modificado en la documentación del proyecto.
- **⚠️⚠️⚠️ Qué son las pruebas de caja blanca?**
    
    - Se centran en la implementación de los programas para elegir los casos de prueba.
    - Lo ideal sería encontrar casos de prueba que recorrieran todos los caminos posibles del flujo de control del programa.
    - Estas pruebas se centran en la estructura interna del programa, analizando los caminos de ejecución.

### PRUEBAS UNITARIAS: ENFOQUE ESTRUCTURAL O DE CAJA BLANCA | ENFOQUE FUNCIONAL O DE CAJA NEGRA

- **Cómo se conocen también las pruebas unitarias?**
    - Se conocen también como "pruebas de componentes".
- **Qué hacen las pruebas unitarias?**
    - Son las pruebas que se hacen a más bajo nivel, sobre los módulos o componentes más pequeños del código fuente del proyecto informático.
- **En qué 2 enfoques pueden desarrollarse las pruebas unitarias?**
    - <ins>Enfoque estructural (o pruebas de caja blanca):</ins>
        - Es la parte de las pruebas unitarias encargadas de la estructura interna del código fuente, desde el que se analizan todos los posibles caminos.
    - <ins>Enfoque funcional (o pruebas de caja negra):</ins>
        - Es la parte de las pruebas unitarias encargada del funcionamiento correcto de las funcionalidades del programa.

* * *

### <ins>ENFOQUE ESTRUCTURAL O DE CAJA BLANCA</ins>

- **⚠️⚠️⚠️ Qué son las pruebas de caja blanca?**
    - Se centran en la implementación de los programas para elegir los casos de prueba.
    - Lo ideal sería hallar los casos de prueba que recorrieran todos los caminos posibles del flujo del control del programa.
- **En qué se centran las pruebas de caja blanca?**
    - En la estructura interna del programa, analizando los caminos de ejecución.
- **Esquema de la estructura que tienen las pruebas de caja blanca:**

![69_04_Pruebas_Caja_Blanca.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/69_04_Pruebas_Caja_Blanca.png)

- **Cómo se obtienen las condiciones deseadas en la salida de la caja blanca?**
    - Primero se dan unas condiciones de entrada al módulo o parte del código que se necesita validar.
    - El código va por la bifurcación que sea, y sale de la caja blanca.
- **Qué permiten las pruebas de caja blanca?**
    - Permiten recorrer todos los posibles caminos del código y ver qué sucede en cada caso posible.
    - Las pruebas se llevan a cabo con datos que garanticen que se han dado todas las combinaciones posibles.
- **Cómo decidimos los valores que deben tomar los datos que se usarán en la caja blanca?**
    - Deberemos buscar por todo el código, asegurándonos que no quede ningún sitio sin revisar.
- **Qué se hace para tener la seguridad de que se van a descubrir todos los errores que puedan haber en el código?**
    - Se diseñan estrategias, como:
        - El método de cobertura del flujo de control.
        - El método de la complejidad ciclomática.

### ENFOQUE ESTRUCTURAL O DE CAJA BLANCA · COBERTURA DEL FLUJO DE CONTROL

- **En qué consiste el método de cobertura de flujo de control?**
    - Consiste a utilizar la estructura de control del programa para obtener los casos de prueba, que son diseñados de manera que garanticen que al menos se pasa una vez por cada camino del programa.
- **Qué posible técnica podemos usar para asegurarnos que se pasa una vez por cada camino del programa?**
    - El diagrama de flujo de control.
- **En qué consiste el diagrama de flujo de control?**
    - En la representación del código del programa y probar:
        - Todos los caminos simples.
        - Todas las condiciones.
        - Todos los bucles del programa.
- **Ejemplo del Diagrama de flujo del listado de asignaturas:**

![69_12_Ejemplo_Diagrama_Flujo.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/69_12_Ejemplo_Diagrama_Flujo.png)

- **Qué tenemos que tener en cuenta para lograr tener un mínimo de garantía de eficacia de que todos los tipos de caminos del programa serán probados?**
    - <ins>Conjunto básico de caminos independientes:</ins>
        - Es el conjunto de caminos independientes que necesitamos cubrir con el juego de pruebas.
    - <ins>Camino independiente:</ins>
        - Camino simple con alguna rama no incluida aún en ningún camino del conjunto básico.
    - <ins>Camino simple:</ins>
        - Camino que no tiene ninguna rama repetida.
    - <ins>Casos de prueba:</ins>
        - Una vez determinado el conjunto básico, necesitamos diseñar un caso de prueba para cada uno de sus caminos de manera que, entre todos, se ejecute al menos una vez cada sentencia.
    - <ins>Condiciones:</ins>
        - Necesitamos asegurarnos que los casos de prueba elaborados de esta manera cubren todas las condiciones del programa que evalúan cierto / falso.
        - Necesitamos tener en cuenta que las condiciones múltiples, se deben dividir en expresiones simples, una para cada operando lógico o de comparación. Así, se deberá probar que se cumpla o no cada parte de cada condición.
        - A cada condición múltiple le corresponderá un nodo para cada condición simple que forme parte de ella.
        - Necesitaremos añadir al gráfico las ramas necesarias para representar correctamente el funcionamiento de las condiciones.
    - <ins>Bucles:</ins>
        - Se deben diseñar los casos de prueba de manera que se intente ejecutar un bucle en diferentes situaciones límite.
- **Ejemplo de código para explicar el funcionamiento de las pruebas unitarias de caja blanca:**

```Java
public float LlistatAssignatures(ArrayList assignatures)
{
      int comptador= 0;
      Iterator iter = assignatures.iterator();
      while (iter.hasNext())
      {
            Assignatura element = (Assignatura) iter.next();
            if (element.getDisponible() == true)
            {
                  System.out.println(element.getNom());
                  comptador = comptador + 1
            }
      }
      return comptador;
}
```

- **Qué muestra la función LlistatAssignatures del código anterior?**
    - Muestra por pantalla las asignaturas que están disponibles para que los alumnos se puedan matricular, y devuelve un valor numérico correspondiente al número de asignaturas disponibles.
- **Ejemplo de la representación gráfica de los nodos de la función LlistatAssignatures, que facilita el cálculo de la complejidad ciclomática:**

![69_12_Ejemplo_Diagrama_Flujo.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/69_12_Ejemplo_Diagrama_Flujo.png)

### ENFOQUE ESTRUCTURAL O DE CAJA BLANCA · COMPLEJIDAD CICLOMÁTICA

- **Como hemos visto, la estrategia de cobertura de flujo de control requiere diseñar casos de prueba suficientes para recorrer toda la lógica del programa. Cómo podemos saber cuantos casos de prueba necesitamos crear y ejecutar?**
    - Con la fórmula de la complejidad ciclomática (CC):
        - ⚠️⚠️⚠️ Complejidad ciclomática = número de ramas - número de nodos + 2
- **Quién creó la fórmula de la complejidad ciclomática?**
    - El matemático Thomas J. McCabe.
- **Ejemplo del cálculo de la complejidad ciclomática del ejemplo de la función LlistatAsignatures:**
    - **⚠️⚠️⚠️** Complejidad ciclomática CC = 8 - 7 + 2 = 3

**![69_12_Ejemplo_Diagrama_Flujo.png](../_resources/69_12_Ejemplo_Diagrama_Flujo.png)**

- **Qué significa que el cálculo de la complejidad ciclomática anterior nos de como resultado 3?**
    - Que será necesario diseñar 3 casos de prueba.
        - Camino1 : 1 - 2 - 7
        - Camino2 : 1 - 2 - 3 - 4 - 6 - 2 - 7
        - Camino3 : 1 - 2 - 3 - 4 - 5 - 6 - 2 - 7
- ** De qué depende el conjunto básico?**
    - Depende del orden en que añadamos los caminos independientes.
    - Una estrategia posible es elegir los caminos de más corto a más largo.
- **Valores del vector de asignaturas:**

![69_13_Vector_Asignaturas.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/69_13_Vector_Asignaturas.png)

- **Qué será necesario para cada uno de los caminos que es necesario recorrer del ejemplo anterior?**
    - Será necesario un vector con unas características concretas.
- **Vector para el camino1:**
    - Vector de asignaturas vacío.
- **Vector para el camino2:**
    - Vector de asignaturas que contenga como mínimo una asignatura que no esté disponible.
- **Vector para el camino3:**
    - Vector de asignaturas que contenga como mínimo una asignatura que esté disponible.
- **Los resultados de las pruebas del ejemplo anterior serían:**
    - Camino1:
        - Entrada (Assignaturas1)
        - Salida esperada: 0
        - Salida real: 0
        - Camino seguido: 1
    - Camino2:
        - Entrada (Assignaturas2)
        - Salida esperada: 1
        - Salida real: 1
        - Camino seguido: 2
    - Camino3:
        - Entrada (Assignaturas3)
        - Salida esperada: 1
        - Salida real: 1
        - Camino seguido: 3
- **En conclusión, que nos permiten hacer las pruebas de caja blanca?**
    - Dentro de las pruebas unitarias sirve para analizar el código de todas sus estructuras, en todos sus caminos de programario.

* * *

### <ins>ENFOQUE FUNCIONAL O PRUEBAS DE CAJA NEGRA</ins>

- ⚠️⚠️⚠️ **Qué son las pruebas de caja negra?**
    - Son pruebas que prueban la funcionalidad del programa.
    - Se diseñan casos de prueba que comprueben las especificaciones del programa.
- **Qué pretenden encontrar las técnicas de prueba de caja negra?**
    - Errores en funciones incorrectas o ausentes.
    - Errores de interfaz.
    - Errores de rendimiento.
    - Errores de inicialización.
    - Errores de finalización.
- **En qué se centran las pruebas de caja negra?**
    - En las funciones y en sus entradas y salidas.
- **Estructura de las pruebas de caja negra:**

![69_14_Estructura_Pruebas_Caja_Negra.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/69_14_Estructura_Pruebas_Caja_Negra.png)

- **Qué es muy importante cuando tenemos que elegir los casos de prueba de caja negra?**
    - Es importante que sean los menores casos de prueba posibles, para que la prueba se pueda ejecutar en un tiempo razonable y, al mismo tiempo, que cubran la variedad de entradas y salidas más amplia posible.
- **Las 5 técnicas usadas para los casos de pruebas de caja negra:**
    - <ins>Clases de equivalencia:</ins>
        - 1\. Determinar los diferentes tipos de entrada y de salida.
        - 2\. Agrupar los tipos de entrada y de salida.
        - 3\. Elegir los casos de prueba para cada tipo o conjunto de datos de entrada y salida.
    - <ins>Análisis de los valores límite:</ins>
        - Estudian los valores iniciales y finales, ya que estadísticamente se ha demostrado que tienen más tendencia a detectar errores.
    - <ins>Estudio de errores típicos:</ins>
        - Hay un conjunto de errores que se repiten en muchos programas; para ello, se necesitaría diseñar casos de prueba que provocasen las situaciones típicas de estos tipos de errores.
    - <ins>Manejo de la interfaz gráfica:</ins>
        - Para provocar el funcionamiento de las interfaces gráficas, se deben diseñar casos de prueba que permitan descubrir errores en el manejo de ventanas, botones, iconos...
    - <ins>Datos aleatorios:</ins>
        - Usar una herramienta que automatice las pruebas y que genere de una manera aleatoria los casos de prueba.
        - Esta técnica no optimiza la elección de los casos de prueba, pero si se hace durante suficiente tiempo con muchos datos, podrá llegar a hacer una prueba bastante completa.
        - Esta técnica se podría usar como complementaria a las anteriores o, en caso de no ser posible aplicar ninguna otra técnica.
- **⚠️⚠️⚠️ Qué ventaja tienen las pruebas de caja negra?**
    - Son independientes del lenguaje o paradigma de programación usado, de manera que son válidas tanto para programación estructurada como para programación orientada a objetos.

### CAJA NEGRA · TÉCNICA "CLASES DE EQUIVALENCIA"

- **En qué consiste la técnica de las clases de equivalencia?**
    - En diseñar los casos de prueba de manera que prueben la mayor funcionalidad posible del programa, pero que no contengan demasiados valores.
- **Qué 3 pasos hay que seguir en la técnica clases de equivalencia?**
    - <ins>1r paso: Identificar las condiciones, restricciones o contenidos de las entradas y de las salidas.</ins>
    - <ins>2o paso: Identificar, a partir de las condiciones, las clases de equivalencia de las entradas y de las salidas:</ins>
        - **Elemento de clase:**
            - Cada elemento de clase debe ser tratado de la misma manera por el programa, pero cada clase tiene que ser tratada de manera diferente en relación a otra clase.
            - Esto asegura que solo probando algún elemento de la clase tendremos la prueba para cualquier elemento de esa clase.
        - **Datos válidos como erróneos:**
            - Las clases deben recoger tanto datos válidos como erróneos, ya que el programa tiene que estar preparado para que no se bloquee bajo ninguna circunstancia.
        - **Rango de valores:**
            - Para especificar el rango de valores que tendrán los datos de entrada.
        - **Valor válido:**
            - Para especificar un valor válido de entrada y otros de no válidos. Por ejemplo, si la entrada empieza en mayúscula se crea una clase válida (con la primera letra en mayúscula) y otra de no válida (con la primera letra en minúscula).
        - **Datos de entrada concretos:**
            - Si hay un conjunto de datos válidos, se generará una clase para cada valor válido y otra para un valor no válido. Por ejemplo:
                - Valores válidos: rojo, naranja, verde -> se generarán 3 clases.
                - Valores no válidos: azul -> se generará 1 clase.
        - **Resultado:**
            - Si no se han recogido ya en las clases anteriores, se debe seleccionar una clase para cada posible clase resultado.
    - <ins>3r paso: Crear los casos de prueba a partir de las clases de equivalencia afectadas:</ins>
        - Elegir un valor que represente cada clase de equivalencia.
        - Diseñar casos de prueba que incluyan los valores de todas las clases de equivalencia edintificadas.
- **Ejemplo de definición de las pruebas de caja negra para una función que devuelve el nombre del mes a partir de su valor numérico:**

```Java
    String nom;
    nom = NomDelMes(3);
    El valor del nom serà Març.
        
        //Será necesario identificar 3 clases de equivalencias
        ..., -02, -01, 00 valors invàlids
    01, 02, 03, 04, 05, 06, 07, 08, 09, 10, 11, 12 valors vàlids
    13, 14, 15, ... valors invàlids.
```

- **Esquema del ejemplo propuesto anterior:**

![69_15_Esquema_Devolver_Nombre_Mes.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/69_15_Esquema_Devolver_Nombre_Mes.png)

### CAJA NEGRA · TÉCNICA "ANÁLISIS DE LOS VALORES LÍMITE"

- **Para qué es adecuada la técnica del análisis de los valores límite?**
    - Los casos de prueba que se centran en los valores límite producen un mejor resultado para la detección de defectos.
- **Qué 4 recomendaciones es necesario seguir para elegir los representantes de cada clase?**
    - En los rangos de valores, elegir los extremos del rango y el valor intermedio.
    - Si se especifican un conjunto de valores, elegir el superior, el inferior, el anterior al inferior y el posterior al superior.
    - Si el resultado se mueve en un determinado rango, debemos elegir los datos de entrada para provocar las salidas:
        - Mínima.
        - Máxima.
        - Valor intermedio.
    - Si el programa elige una lista o tabla, elegir:
        - El elemento primero.
        - El último elemento.
        - El elemento intermedio.
- **Qué otra manera tenemos para elegir buenos representantes de cada clase?**
    - Aprovechando la experiencia previa: Hay un conjunto de errores que se repiten en muchos programas, y podría ser una buena estrategia utilizar casos de prueba que se centren en buscar este tipo de errores.
- **4 errores que suelen repetirse en muchos programas:**
    - El valor 0 suele provocar errores. Por ejemplo la división entre 0 bloquea el programa.
    - La posibilidad de no introducir ningún valor, o introducir solo uno.
    - Pensar que el usuario puede introducir entradas que no son normales, por eso se recomienda ponerse en el peor caso.
    - Probar de introducir valores lo más grande posibles, ya que los desbordamientos de memoria son habituales.

### CAJA NEGRA · TÉCNICA "ESTUDIO DE ERRORES TÍPICOS"

### CAJA NEGRA · TÉCNICA "MANEJO DE INTERFAZ GRÁFICA"

### CAJA NEGRA · TÉCNICA "DATOS ALEATORIOS"

### EJEMPLO DE PRUEBA DE CAJA NEGRA

- Necesitamos probar el siguiente procedimiento:
    
    - Funció Buscar (DNI as string, vectMatricula de Matricules) retorna Matricula
- A la función Buscar le proporcionamos un String que representa el DNI del alumno, y un vector llamado vectMatricula que almacena las matrículas de los alumnos.
    
- La función busca en el vector vectMatricula la matrícula del alumno.
    
- La función devuelve la matrícula del alumno si la encuentra o una matrícula vacía si no la encuentra.
    
- Para simplificar el juego de pruebas, el número de matrículas que admite la función Buscar es 10.
    
- Consideraciones para la variable DNI:
    
    - 00000001A Prova vàlida.
        
    - Null Prova invàlida, el DNI no té valor.
        
    - 00000001 Prova invàlida, el DNI té un format incorrecte, falta la lletra.
        
    - 00000001AA Prova invàlida, el DNI té un format incorrecte.
        
    - AAAAAAAAA Prova invàlida, el DNI té un format incorrecte.
        
- Para el vectMatricula tendremos la consideración que puede contener de 0 a 10 matrículas:
    
    - `[]`. Prova vàlida, vector buit.
        
    - `[matrícula1]`. Prova vàlida, vector amb una matrícula.
        
    - `[matrícula1, matrícula2, matrícula3, … matrícula10]`. Prova vàlida, vector amb un nombre de matrícules entre 0 i 10.
        
    - `[matrícula1, matrícula2, matrícula3, … matrícula10, matrícula11]`. Prova invàlida, vector amb un nombre de matrícules superior a 10.
        
- Para la salida:
    
    - `Alumne.DNI = DNI`. Prova vàlida. Classe amb les dades d’un alumne.
        
    - Classe buida. Prova vàlida. S’ha buscat el DNI d’una persona que no és alumne.
        
    - `Alumne.DNI <> DNI`. Prova invàlida. Classe amb les dades d’un altre alumne.
        
    - Classe buida. Prova invàlida. S’ha buscat el DNI d’un alumne i no s’ha trobat.
        

* * *

### USO DE INTERFAZ GRÁFICA

- **Tipos de pruebas para interfaces gráficas:**
    - <ins>Realizar pruebas sobre ventanas:</ins>
        - iconos de cerrar
        - minimizar
        - ...
    - <ins>Realizar pruebas sobre menús y uso del ratón.</ins>
    - <ins>Realizar pruebas de entrada de datos:</ins>
        - cuadros de textos
        - listas desplegables
        - ...
    - <ins>Realizar pruebas de documentación y ayuda del programa.</ins>
    - <ins>Otros.</ins>
- **Ejemplo de caso de prueba 1 para interfaz gráfica:**
    - Entrada:
        - usuario correcto
        - password correcta
        - pulsar button de acceso al sistema
    - Condiciones de ejecución:
        - en la tabla existe este usuario con la contraseña y con un intento fallido (número inferior a 3)
    - Resultado esperado:
        - dar acceso al sistema y reflejar que el número de intentos para el usuario correcto es cero en la tabla USUARI (cuenta, password, número de intentos).
- **Ejemplo de caso de prueba 2 para interfaz gráfica:**
    - Entrada
        - usuario incorrecto
        - password correcta
        - pulsar button de acceso al sistema
    - Condiciones de ejecución:
        - en la tabla no existe este usuario con esta password.
    - Resultado esperado:
        - no dar acceso al sistema.

* * *

### PRUEBAS DE INTEGRACIÓN: INCREMENTAL ASCENDENTE | INCREMENTAL DESCENDENTE

- **Qué necesitamos hacer una vez hemos probado que los componentes individuales del programa funcionan correctamente y no tienen errores?**
    - Necesitamos integrar los componentes en un sistema completo que deberá ser probado.
- **⚠️⚠️⚠️ Qué objetivo tienen las pruebas de integración?**
    - Localizar errores en las interfaces entre las distintas unidades.
    - Validar que las partes del código que ya han estado probadas de forma independiente sigan funcionando correctamente en ser integradas.
- **Los elementos se integran todos al mismo tiempo?**
    - No, se utilizan distintas estrategias de integración.
- **Esquema de integración incremental de componentes:**

![69_05_Esquema_Integracion_Incremental.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/69_05_Esquema_Integracion_Incremental.png)

- **Qué facilita la integración incremental de componentes?**
    - Se facilita la localización del error cuando se produce, porque se sabe cuáles son los últimos módulos que se han integrado y cuando se ha producido el error.
- **Cómo se organizan los módulos en la integración incremental de componentes?**
    - En la parte alta el módulo o los módulos principales (a veces denominados padres). Estos hacen llamadas a módulos subordinados inferiores (hijos) y así sucesivamente.
- **Qué módulos son los que son más cercanos al usuario?**
    - Los superiores.
    - Incluyen la interfaz gráfica (entorno gráfico, menús, ayudas...).
- **Qué módulos son los más cercanos a la estructura física de la aplicación (bases de datos, maquinaria, ...)?**
    - Los inferiores.

### A) PRUEBA DE INTEGRACIÓN INCREMENTAL ASCENDENTE

- **Cómo se inicia la prueba de integración ascendente?**
    - Agrupando los módulos de nivel más bajo, agrupándolos por las funcionalidades.
    - Se crea un módulo impulsor que irá realizando llamadas a los diferentes módulos a partir de las precondiciones indicadas e irá recogiendo los resultados de cada llamada.
- **Qué sucede a medida que las pruebas van saliendo positivas?**
    - Se irá escalando por el árbol de jerarquías con el módulo impulsor hacia los otros módulos, haciendo las llamadas pertinentes de forma recursiva.
- **Qué sucede en la última llamada?**
    - Se llama al programario entero con los valores de entrada reales (analizando también los valores reales de salida).
- **Esquema de pruebas de integración ascendente:**

![69_06_Pruebas_Integracion_Ascendente.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/69_06_Pruebas_Integracion_Ascendente.png)

- **Esquema de la primera fase de las pruebas de integración ascendentes. Cada módulo tiene que ser probado por separado, para eso se tiene que construir un módulo impulsor independiente para probar cada módulo:**

**![69_07_Primera_Fase_Pruebas_Integracion_Ascendentes.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/69_07_Primera_Fase_Pruebas_Integracion_Ascendentes.png)

- **Esquema de la siguiente fase, una vez finalizadas las pruebas sobre los módulos de nivel más bajo, los módulos (07, 08, 12, 13, 14 y 11). El siguiente paso es continuar con los módulos del siguiente nivel, lo que implica crear nuevos módulos impulsores (04, 09, 10 y 06):**

![69_08_Siguiente_Fase_Pruebas_Integracion_Ascendentes.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/69_08_Siguiente_Fase_Pruebas_Integracion_Ascendentes.png)

![69_09_Siguiente_Fase_Pruebas_Integracion_Ascendentes.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/69_09_Siguiente_Fase_Pruebas_Integracion_Ascendentes.png)

![69_10_Siguiente_Fase_Pruebas_Integracion_Ascendentes.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/69_10_Siguiente_Fase_Pruebas_Integracion_Ascendentes.png)

![69_11_Siguiente_Fase_Pruebas_Integracion_Ascendentes.png](../_resources/69_11_Siguiente_Fase_Pruebas_Integracion_Ascendent.png)

### A1) VENTAJAS DE LAS PRUEBAS DE INTEGRACIÓN ASCENDENTE

- **Cuáles son las 3 ventajas tienen las pruebas de integración ascendente?**
    - Orden adecuado:
        - Primero se evalúan los módulos inferiores, que son los que acostumbran a tener el procesamiento más complejo. Se solucionan los errores y se nutren los datos del sistema.
    - Más sencillez:
        - Las entradas para las pruebas son más fáciles de crear, ya que los módulos inferiores suelen tener funciones más específicas.
    - Mejor observación de los resultados de las pruebas:
        - Como se empieza por los módulos inferiores, es más sencillo observar los resultados de las pruebas.

### A2) DESVENTAJAS DE LA INTEGRACIÓN ASCENDENTE

- **Qué 2 desventajas tienen las pruebas de integración ascendente?**
    - Análisis parcial:
        - Hasta que no se haga la llamada al último módulo no se valida el sistema como tal.
    - Alto tiempo de dedicación:
        - Será necesario dedicar mucho tiempo a implementar cada módulo impulsor, que pueden llegar a ser muchos.

### B) PRUEBA DE INTEGRACIÓN INCREMENTAL DESCENDENTE

- **Cómo se inicia la estrategia de desarrollo de las pruebas de integración descendente?**
    - Empieza por el módulo de control principal (el más importante, el de más nivel).
    - Una vez validado, se irán integrando los otros módulos que dependen de forma progresiva, sin seguir una estrategia concreta, solo teniendo en cuenta el nuevo módulo incorporado a las pruebas tendrá ya validados los módulos que lo referencian.
- **Cuáles son las 3 etapas de la integración descendente?**
    - 1\. Se selecciona el módulo más importante, el de mayor nivel. Este módulo hará de impulsor. Será necesario escribir otros módulos ficticios que simulen los módulos que llamará el principal.
    - 2\. A medida que se van integrando módulos, será necesario probarlos independientemente y de forma conjunta con los otros módulos ya probados. Una vez se ha finalizado la prueba, se sustituye el módulo fictício creado por el real que se ha integrado.
    - 3\. Entonces será necesario escribir los módulos fictícios subordinados que se necesiten para la prueba del nuevo módulo incorporado.

### B1) VENTAJAS DE LA INTEGRACIÓN DESCENDENTE

- **Cuáles son las 3 ventajas de la integración descendente?**
    - Identificación de la estructura: permite ver la estructura del sistema des de un principio, facilitando la elaboración de demostraciones de su funcionamiento.
    - Diseño descendiente: primero se definen las interfaces de los diferentes subsistemas para luego seguir con las funciones específicas de cada uno por separado.
    - Detección más rápida de los errores que se encuentran en los módulos superiores por el hecho de detectarse en una etapa inicial.

### B2) DESVENTAJAS DE LA INTEGRACIÓN DESCENDENTE

- **Qué 2 desventajas tiene la integración descendiente?**
    - Coste muy elevado: será necesario implementar muchos módulos adicionales para ofrecer los módulos fictícios a fin de ir efectuando las pruebas.
    - Alta dificultad: en querer hacer una distribución de las pruebas del más genérico al más detallado, los datos que se deberán utilizar son difíciles de conseguir, ya que son los módulos de nivel más bajo los que tendrán los detalles.

* * *

### PRUEBAS DE CARGA Y ACEPTACIÓN

- **Qué paso es el siguiente a las pruebas unitarias y las pruebas de integración?**
    - La realización de las pruebas de carga y luego las pruebas de aceptación.
- **En qué consisten las pruebas de carga?**
    - Son pruebas que tienen como objetivo comprobar el rendimiento y la integridad de la aplicación ya acabada con datos reales.
    - Se trata de simular el entorno de explotación de la aplicación.
- **Con qué pruebas quedaría probada la aplicación a escala de laboratorio?**
    - Con las pruebas unitarias y de integración.
- **Qué usamos para probar la aplicación en situaciones reales?**
    - Las pruebas de carga y aceptación.
- **Qué objetivo tienen las pruebas de aceptación?**
    - Obtener la aprobación del cliente sobre la calidad de funcionamiento del sistema desarrollado y probado.
- **⚠️⚠️⚠️ Qué son las pruebas alfa?**
    - Se invita al cliente a que venga al entorno de desarrollo a probar el sistema.
    - Se trabaja en un entorno controlado y el cliente siempre tiene un experto a mano para ayudarle a usar el sistema y para analizar los resultados.
- **⚠️⚠️⚠️ Qué son las pruebas beta?**
    - Vienen después de las pruebas alfa.
    - Se desarrollan en el entorno del cliente, un entorno fuera del control del desarrollador y del equipo de trabajo.
    - El cliente se queda solo con el producto e intenta encontrar errores, de los cuales informará al desarrollador.
- **Dónde suelen realizarse las pruebas alfa y beta?**
    - En productos que se venderán a muchos clientes o que usarán muchos usuarios.

* * *

### PRUEBAS DE SISTEMA Y DE SEGURIDAD

- **Qué son las pruebas de sistema y de seguridad?**
    - Son las pruebas que se llevan a cabo una vez finalizadas las pruebas unitarias (cada módulo por separado), las pruebas de integración de los módulos, las pruebas de carga y las pruebas de aceptación por parte del usuario.
    - El usuario ha podido verificar la aplicación desarrollada llevando a cabo las pruebas de aceptación.
- **⚠️⚠️⚠️ Definición de pruebas de sistema:**
    - Sirven para validar la aplicación una vez esta haya sido integrada con la resta del sistema del usuario.
    - Aunque la aplicación haya sido validada de forma independiente, en las pruebas de sistema se realizará una segunda validación con la aplicación ya integrada en su entorno de trabajo real.
- **6 tipos de pruebas para desarrollar durante las pruebas del sistema:**
    - <ins>1\. Pruebas de rendimiento:</ins>
        - Valoran:
            - el tiempo de respuesta de la nueva aplicación.
            - el espacio que ocupará la aplicación en el disco.
            - el flujo de datos que generará a través de un canal de comunicación.
    - <ins>2\. Pruebas de resistencia:</ins>
        - Valoran la resistencia de la aplicación para determinadas situaciones del sistema.
    - <ins>3\. Pruebas de robustez:</ins>
        - Valoran la capacidad de la aplicación para soportar diversas entradas incorrectas.
    - <ins>4\. Pruebas de seguridad:</ins>
        - Ayudan a determinar:
            - los niveles de permisos de los usuarios.
            - las operaciones que podrán llevar a cabo los usuarios.
            - las operaciones de acceso al sistema.
            - las operaciones de acceso a los datos.
    - <ins>5\. Pruebas de usabilidad:</ins>
        - Determinan la calidad de la experiencia de un usuario en la manera de interactuar con el sistema.
    - <ins>6\. Pruebas de instalación:</ins>
        - Indican las operaciones de arranque y de actualización de los programarios.
- **8 objetivos de las pruebas de sistema:**
    - Observar si la aplicación hace las funciones que tiene que hacer y si el nuevo sistema se comporta como debería.
    - Observar los tiempos de respuesta para las distintas pruebas de rendimiento, volumen y sobrecarga.
    - Observar la disponibilidad de los datos en el momento de recuperar un fallo.
    - Observar la usabilidad.
    - Observar la instalación:
        - Asistentes.
        - Operadores de arranque de la aplicación.
        - Actualizaciones del programario.
        - ...
    - Observar el entorno una vez la aplicación está funcionando a pleno rendimiento:
        - Comunicaciones.
        - Interacciones con otros sistemas.
        - ...
    - Observar el funcionamiento de todo el sistema a partir de las pruebas globales hechas.
    - Observar la seguridad:
        - Control de acceso.
        - Intrusiones.
        - ...
- **⚠️⚠️⚠️ Qué permiten las pruebas de validación?**
    - Permiten comprobar si, efectivamente, se cumplen los requisitos propuestos por nuestro sistema.

* * *

### PRUEBAS DE REGRESIÓN Y PRUEBAS DE HUMO

- **⚠️⚠️⚠️ Qué hacen las pruebas de regresión?**
    - Buscan detectar posibles nuevos errores o problemas que puedan darse al haber introducido cambios o mejoras en el programa.
- **Por qué se tienen que realizar las pruebas de regresión al finalizar todas las otras pruebas?**
    - Porque los cambios que se realizan para solucionar los problemas que marcan los casos de pruebas, pueden generar problemas en otras partes.
- **Qué problema tiene el automatizar las pruebas de regresión?**
    - Que requiere un mantenimiento muy complejo.
- **⚠️⚠️⚠️ Qué son las pruebas de humo?**
    - Se usan para describir la validación de los cambios de código en el programario, antes que los cambios en el código se registren en la documentación del proyecto.
    - Son pruebas de ejecución rápida y comprueban las funciones básicas del programario.

* * *

### 1.3.3. Ejecución de las pruebas

- **Cuándo se da el proceso de ejecución de las pruebas?**
    - Tras la planificación de los procedimientos de pruebas y del diseño de los casos de pruebas.
- **Qué 4 pasos comporta la ejecución de las pruebas?**
    - 1\. Ejecución de las pruebas.
    - 2\. Comprobación de si se ha producido algún error en la ejecución de las pruebas.
    - 3\. Si no ha habido ningún error:
        - Verificar la finalización de las pruebas.
        - Se valida si se necesitan pruebas adicionales:
            - Si se necesitan pruebas adicionales:
                - Será necesario validar que no existen condiciones anormales:
                    - Si hay condiciones anormales:
                        - Se finaliza el proceso de pruebas haciendo una evaluación del mismo proceso.
                    - Si no hay condiciones anormales:
                        - Será necesario depurar las pruebas.
            - Si no se necesitan pruebas adicionales:
                - Se finaliza el proceso de pruebas haciendo una evaluación del mismo proceso.
    - 4\. En caso de haber encontrado errores en la ejecución de las pruebas, se deberá observar si estos errores se deben a:
        - Un defecto en el programario:
            - La ejecución de las pruebas ha cumplido su cometido y se necesitará:
                - Depurar el código de programación.
                - Localizar el o los errores.
                - Solucionar el error para volver al punto inicial, en que se volverán a ejecutar las pruebas y se volverá a validar si el cambio ha sido exitoso.
        - Un defecto en el diseño de las pruebas:
            - Se necesitará revisar las pruebas que se han ejecutado:
                - Depurándolas.
                - Localizando el o los errores.
                - Solucionando el o los errores.
                - Una vez solucionado el error se vuelve al punto inicial y se vuelve a ejecutar, para comprobar si el cambio ha sido exitoso.
- **Esquema de ejecución de las pruebas:**

![69_03_Ejecucion_Pruebas.png](https://raw.githubusercontent.com/sufigueroa87/Apuntes/main/IOC_Institut_Obert_De_Catalunya/Im%C3%A1genes/69_03_Ejecucion_Pruebas.png)

* * *

### 1.3.4. Finalización: Evaluación y Análisis de Errores

- **Qué necesitamos para poder cerrar el proceso de prueba?**
    - Una evaluación.
    - Un análisis de errores localizados.
    - Un análisis del tratamiento de errores.
    - Un análisis de la corrección de errores.
    - Un análisis de la reevaluación de errores.
- **Qué es muy importante si tenemos que rehacer los procedimientos de pruebas?**
    - La creación de nuevos casos de pruebas y no la readaptación de los casos de pruebas reexistentes.
- **Qué aporta crear nuevos casos de pruebas en vez de rediseñar los ya existentes?**
    - Se estará rediseñando los procedimientos de pruebas sobre el mismo código fuente, eliminando el riesgo de hacer que el código fuente sea el que esté adaptando los casos de pruebas.
- **Por qué es muy importante escribir un informe que ayude a almacenar la experiencia que se ha recogido a lo largo del procedimiento de pruebas?**
    - Esta información será muy importante para proyectos futuros, ya que ayudará a no repetir los mismos errores detectados.
- **Qué 9 informaciones debe contener el informe que almacena la experiencia que se ha recogido a lo largo del procedimiento de pruebas?**
    - El número de casos de prueba generados.
    - El número de errores detectados en cada fase del proyecto.
    - El tiempo y recursos dedicados a los procedimientos de pruebas.
    - Los tipos de pruebas llevadas a cabo.
    - Los tipos de pruebas que más errores han detectado.
    - El nivel de calidad del programario.
    - Los módulos donde más errores se han detectado.
    - Los errores que han llegado hasta los usuarios finales.
    - El número de casos de prueba erróneos detectados.

* * *

### 1.3.5. Depuración del código fuente

- **Qué es la depuración del código fuente?**
    - Consiste en ir ejecutando paso a paso el código fuente, observando los estados intermedios de las variables y los datos implicados para facilitar la corrección de errores.
- **Qué 4 procedimientos están vinculados a la depuración del código fuente?**
    - Identificar la casuística para poder reproducir el error.
    - Diagnosticar el problema.
    - Solucionar el error atacando el problema.
    - Verificar la corrección del error y verificar que no se han introducido nuevos errores al resto del programa.
- **Qué permite la depuración del código?**
    - Permite la creación de un punto en el código fuente hasta al cual el programa será ejecutado de forma directa.
    - Cuando la ejecución haya llegado a este punto de rotura, se podrá avanzar en la ejecución del código paso a paso hasta encontrar el error que se está buscando.
- **Qué herramienta ayuda en la depuración del código fuente?**
    - La utilización de ficheros llamados registros (*logs*).
- **Qué hacen los ficheros *logs*?**
    - Habitualmente son ficheros de texto.
    - Registran toda la información vinculada a la ejecución de un programario con el objetivo de que el programador pueda hacer una revisión paso a paso de cómo ha evolucionado dicha ejecución y localizar errores o malos funcionamientos.
- **Para qué es muy útil, también, la depuración del código?**
    - Para ejecutar pruebas de:
        - Integración.
        - Sistema.
        - Adaptación.

* * *

## 1.4. Herramientas para la realización de pruebas

- **Para qué nos sirven las herramientas informáticas para la realización de pruebas?**
    - Nos ayudan a poder automatizar:
        - La tarea de ejecutar las pruebas.
        - Algunos procesos que es necesario hacer para implementar las pruebas:
            - Planificación.
            - Diseño...

* * *

### 1.4.1. Beneficios y problemas del uso de herramientas de pruebas

- **Beneficios del uso de herramientas de pruebas:**
    - Automatizar una tarea que muchas veces es repetitiva y puede reclamar mucho tiempo a los implicados si se tiene que hacer a mano.
    - Ofrece la posibilidad de:
        - Generar los casos de pruebas.
        - Ejecutar los casos de pruebas.
        - Comparar los resultados obtenidos con los resultados esperados.
    - Se minimizan la aparición de errores.
    - Muy útiles para confirmar que un error se ha solucionado.
    - El programa automatiza las pruebas de manera que no se repitan los posibles errores de programación.
    - Ofrecen muchas funcionalidades que permiten tener más información de las pruebas como del código desarrollado.
- **Puntos flojos (problemas) del uso de herramientas de pruebas:**
    - Se requiere tiempo para aprender a hacer uso correcto del programario.
    - Si no hay una buena configuración y buena selección de las pruebas, los resultados obtenidos por las herramientas en la realización de las pruebas:
        - No serán fiables.
        - Se podrían dar como buenos resultados que no lo son.

* * *

### 1.4.2. Algunas herramientas de pruebas de programario

- **Cómo podemos clasificar las herramientas de pruebas del programario?**
    - En función del lenguaje de programación.
    - En función de si son privativas o de código abierto.
    - En función del tipo de pruebas que permiten llevar a cabo.

### **EJEMPLOS DE HERRAMIENTAS QUE NOS SIRVEN PARA CADA TIPO DE PRUEBA**

- **Pruebas unitarias:**
    - <ins>JUnit:</ins>
        - Automatiza las pruebas unitarias y de integración.
        - Provee clases y métodos que facilitan la tarea de efectuar pruebas en el sistema para asegurar la consistencia y funcionalidad del programario desarrollado.
- **Pruebas estáticas de código:**
    - <ins>PMD:</ins>
        - Puede ser integrado por diferentes herramientas:
            - JDeveloper
            - Eclipse
            - jEdit
        - Permite encontrar errores :
            - En el manejo de las excepciones.
            - En código muerto.
            - En código sin optimizar.
            - En código duplicado...
    - <ins>FindBugs:</ins>
        - Puede integrarse en Eclipse.
        - Realiza un escaneo de código mediante el cual encuentra:
            - Errores comunes.
            - Malas prácticas de programación.
            - Código vulnerable.
            - Mal rendimiento.
            - Mala seguridad...
    - <ins>YASCA:</ins>
        - Permite encontrar vulnerabilidades de:
            - Seguridad
            - Calidad en el código
            - Rendimiento...
        - Aprovecha las funcionalidades de los conectores:
            - FindBugs
            - PMD
            - Jlint
- **Pruebas de rendimiento:**
    - <ins>JMeter:</ins>
        - Permite efectuar pruebas sobre recursos estáticos o dinámicos de:
            - rendimiento
            - estrés
            - carga
            - volumen
    - <ins>OpenSTA:</ins>
        - Permite captar peticiones del usuario generadas en un navegador web, tras guardarlas y poderlas editar para su posterior uso.
    - <ins>WebLoad:</ins>
        - Permite llevar a cabo pruebas de rendimiento a través de un entorno gráfico en el que se pueden:
            - Desarrollar las pruebas.
            - Grabar las pruebas.
            - Editar el *script* de las pruebas.
    - <ins>Grinder:</ins>
        - Es un framework (entorno de trabajo) escrito en Java, sobre el que se pueden ejecutar pruebas de rendimiento, mediante *scripts* escritos en lenguaje Java.
        - Permite grabar las peticiones del cliente sobre un navegador web para ser reproducido después.
- **Pruebas de aceptación:**
    - <ins>Fitness:</ins>
        - Permite comparar lo que tiene que hacer el programa con lo que realmente hace.
        - Se pueden efectuar:
            - Pruebas de aceptación.
            - Pruebas de reglas de negocio.
    - <ins>Avignon:</ins>
        - Permito a los usuarios expresar pruebas de aceptación de una forma no ambigua antes que comience el desarrollo.
        - Trabaja en conjunto con:
            - JUnit
            - HTTPUnit...

* * *

# Actividades:

- **Qué es una pila?**
    - Una lista o estructura de datos en que la forma de acceso a sus elementos es de tipo LIFO (Last In First Out, el último en entrar es el primero en salir).
    - La lista permite almacenar datos y recuperarlos.
- **Qué es JUnit?**
    - Es un framework para automatizar las pruebas unitarias de aplicaciones Java; permite la ejecución de clases Java de manera controlada, con el objetivo de poder evaluar si el funcionamiento de cada uno de los métodos de la clase se comporta como se espera.

* * *

# Ejercicios:

- **Marca si los siguientes contenidos pertenecen V o no F al plan de pruebas:**
    - **Identificador del plan de pruebas -> V**
    - **Descripción del plan de pruebas -> V**
    - Descripción del proyecto -> F
    - **Elementos del programario que no se tienen que probar -> V**
    - **Definición de la configuración del plan de pruebas -> V**
    - Requisitos del proyecto -> F
    - **Documentos a entregar -> V**
    - **Responsables y responsabilidades -> V**
    - Partes interesadas (o stakeholders) -> F
    - **Calendario del plan de pruebas -> V**
    - Calendario de la fase de desarrollo -> F
- **Relacionar los tipos de pruebas con los objetivos o características que las definen:**
    - Son las encargadas de detectar errores en la implementación de los requerimientos del usuario -> **TIPOS DE PRUEBAS FUNCIONALES**
    - El método usado es el de caja blanca, el de diseño descendiente (o top-down) y el de bottom-up -> **TIPOS DE PRUEBAS DE INTEGRACIÓN**
    - Su finalidad es detectar errores en lograr los requerimientos -> **TIPOS DE PRUEBAS DE SISTEMAS**
    - Su objetivo es validar la aplicación por parte de los usuarios -> **TIPOS DE PRUEBAS DE ACEPTACIÓN**
- **Completa los espacios en blanco:**
    - Las pruebas **DE CAJA NEGRA** prueban la funcionalidad del programa para el cual se diseñan casos de prueba que comprueben las especificaciones del programa.
    - Las pruebas **DE CAJA BLANCA** se centran en la implementación de los programas para elegir casos de prueba. Lo ideal sería buscar los casos de prueba que recorran todos los caminos posibles del flujo de control del programa. Estos se centran en la estructura interna del programa todo analizando los caminos de ejecución.
- **Completa los espacios en blanco:**
    - Una ventaja de las pruebas de **CAJA NEGRA** es que son independientes del lenguaje o paradigma de programación usado, de manera que son válidas tanto para una programación estructurada como para una programación orientada a objetos.
    - El enfoque estructural o las pruebas de **CAJA BLANCA,** dentro de las pruebas unitarias, sirve para analizar el código en todas sus estructuras, en todos sus caminos del programario. Pero existe otro tipo de tipos de pruebas que se basan en un enfoque más funcional, llamadas pruebas de **CAJA NEGRA**.
- **Elije las opciones correctas eligiendo los tipos de pruebas que se desarrollarán durante las pruebas del sistema:**
    - **Pruebas de rendimiento -> OK**
    - **Pruebas de robustez -> OK**
    - Pruebas de aceptación
    - **Pruebas de resistencia -> OK**
    - **Pruebas de seguridad -> OK**
    - Pruebas de depuración
    - **Pruebas de usabilidad -> OK**
    - **Pruebas de instalación -> OK**
    - Pruebas de caja blanca
    - Pruebas de "humo"
